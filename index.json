[{"categories":["工具使用"],"content":"nmap使用基础 Nmap基础 ","date":"2023-03-28","objectID":"/post/543fca94/:0:0","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"常见用法与参数 Nmap默认发送ARP的ping数据包，检测常用端口开放 nmap 192.168.244.160 快速扫描多个IP地址目标 nmap 192.168.244.160 192.168.244.1 简单扫描，并对返回的结果详细描述输出 nmap -vv 192.168.244.160 指定端口和范围扫描 Nmap默认扫描常用端口号，使用-p参数设定扫描的端口范围 nmap -p 端口范围 目标主机IP nmap -p 80-443 192.168.244.160 ","date":"2023-03-28","objectID":"/post/543fca94/:1:0","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"网段扫描格式 nmap -sP \u003cnetwork address \u003e \u003c/CIDR \u003e 10.1.1.0/8 = 10.1.1.1-10.255.255.255 # a段扫描 10.1.1.0/16 = 10.1.1.1-10.1.255.255 # b段扫描 10.1.1.0/24 = 10.1.1.1-10.1.1.255 # c段扫描 ","date":"2023-03-28","objectID":"/post/543fca94/:1:1","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"从文件中读取需要扫描的 IP 列表 nmap -iL ip-address.txt ","date":"2023-03-28","objectID":"/post/543fca94/:1:2","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"扫描除过某一个 ip 外的所有子网主机 nmap 192.168.244.1/24 -exclude 192.168.244.1 ","date":"2023-03-28","objectID":"/post/543fca94/:1:3","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"扫描除过某一个文件中的 ip 外的子网主机 nmap 192.168.244.1/24 -exclude robots.txt ","date":"2023-03-28","objectID":"/post/543fca94/:1:4","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"显示扫描的所有主机的列表 nmap -sL 192.168.244.1/24 ","date":"2023-03-28","objectID":"/post/543fca94/:1:5","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-sP ping扫描：类似与windows/linux中ping扫描方式，常使用该命令去扫描一个内网范围来进行主机发现 nmap -sP 192.168.244.1-255/nmap -sP 192.168.244.1/24 ","date":"2023-03-28","objectID":"/post/543fca94/:1:6","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-sS SYN 半开放扫描 nmap -sS 192.168.244.160 SYN扫描,又称为半开放扫描，它不打开一个完全的TCP连接，执行得很快，效率高 优点：Nmap发送SYN包到远程主机，但是它不会产生任何会话，目标主机几乎不会把连接记入系统日志。 （防止对方判断为扫描攻击），扫描速度快，效率高，在工作中使用频率最高 缺点：需要root权限 ","date":"2023-03-28","objectID":"/post/543fca94/:1:7","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-sT TCP 扫描 nmap -sT 192.168.244.160 等同于 192.168.244.160 Tcp connect() scan (sT)和上面的Tcp SYN 对应，TCP connect()扫描就是默认的扫描模式. 不同于Tcp SYN扫描,Tcp connect()扫描需要完成三次握手,并且要求调用系统的connect(). 扫描技术只适用于找出 TCP 和 UDP 端口。 优点：不需要root权限 缺点：这种扫描很容易被检测到，在目标主机的日志中会记录大批的连接请求以及错误信息， 由于它要完成3次握手，效率低，速度慢 ","date":"2023-03-28","objectID":"/post/543fca94/:1:8","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-sU UDP 扫描 nmap -sU 192.168.244.160 这种扫描技术用来寻找目标主机打开的 UDP 端口，它不需要发送任何的 SYN 包，因为这种技术是针对 UDP 端口的。 UDP 扫描发送 UDP 数据包到目标主机，并等待响应。如果返回 ICMP 不可达的错误消息，说明端口是关闭的，如果 得到正确的适当的回应，说明端口是开放的。 缺点：扫描速度较慢 ","date":"2023-03-28","objectID":"/post/543fca94/:1:9","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-sF FIN 标志的数据包扫描 namp -sF 192.168.224.160 有时候TcpSYN扫描不是最佳的扫描模式,因为有防火墙的存在.目标主机有时候可能有IDS和IPS系统的存在,防火墙会阻止 掉SYN数据包。发送一个设置了FIN标志的数据包并不需要完成TCP的握手.和sS扫描效果差不多，比sT速度快 ","date":"2023-03-28","objectID":"/post/543fca94/:1:10","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-sV Version 版本检测扫描 nmap -sV 192.168.244.160 版本检测是用来扫描目标主机和端口上运行的软件的版本,使用版本检测扫描之前需要先用 TCP SYN 扫描开放了哪些端口 扫描速度较慢 ","date":"2023-03-28","objectID":"/post/543fca94/:1:11","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-O OS 操作系统类型的探测 nmap -O 192.168.244.160 远程检测操作系统和软件，Nmap 的 OS 检测技术在渗透测试中用来了解远程主机的操作系统和软件是非常有用的， 通过获取的信息你可以知道已知的漏洞。Nmap 有一个名为的 nmap-OS-DB 数据库，该数据库包含超过 2600 种 操作系统的信息。Nmap 把 TCP 和 UDP 数据包发送到目标机器上，然后检查结果和数据库对照。 ","date":"2023-03-28","objectID":"/post/543fca94/:1:12","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"–osscan-guess 猜测匹配操作系统 nmap -O --osscan-guess 192.168.244.160 通过 Nmap 准确的检测到远程操作系统是比较困难的，需要使用到 Nmap 的猜测功能选项，–osscan-guess 猜测认为最接近目标的匹配操作系统类型。 ","date":"2023-03-28","objectID":"/post/543fca94/:1:13","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-PN No ping 扫描 nmap -O -PN 192.168.244.160 如果远程主机有防火墙，IDS 和 IPS 系统，你可以使用 -PN 命令来确保不 ping 远程主机，因为有时候防火墙会组织掉 ping 请求。-PN 命令告诉 Nmap 不用 ping 远程主机。有时候使用 -PN 参数可以绕过 PING 命令，但是不影响主机的系统的发现。 ","date":"2023-03-28","objectID":"/post/543fca94/:1:14","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-T 设置时间模板 nmap -sS -T\u003c0-5\u003e 192.168.168.160 优化时间控制选项的功能很强大也很有效，但有些用户会被迷惑。此外， 往往选择合适参数的时间超过了所需优化的扫描时间。因此，Nmap 提供了一些简单的 方法，使用 6 个时间模板，使用时采用 - T 选项及数字 (0 - 5) 或名称。模板名称有 paranoid (0)、sneaky (1)、polite (2)、normal(3)、 aggressive (4)和insane (5) paranoid、sneaky 模式用于 IDS 躲避 Polite 模式降低了扫描 速度以使用更少的带宽和目标主机资源。 Normal 为默认模式，因此 - T3 实际上是未做任何优化。 Aggressive 模式假设用户具有合适及可靠的网络从而加速扫描. nsane 模式假设用户具有特别快的网络或者愿意为获得速度而牺牲准确性。 ","date":"2023-03-28","objectID":"/post/543fca94/:1:15","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-traceroute 路由跟踪扫描：通过路由器追踪查处从我们电脑所在地到目标地之间所经常的网络节点，并可以看到通过各个节点所花费的时间。 nmap -traceroute www.baidu.com ","date":"2023-03-28","objectID":"/post/543fca94/:1:16","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-A 综合扫描：包括系统探测，版本探测，脚本扫描，路由跟踪，速度很慢 nmap -A 192.168.244.160 多参数混合 nmap -vv -p 1-100,3306,3389 -O -traceroute 192.168.244.160 Nmap输出格式 nmap -O -PN 192.168.244.160 -oN 1.txt #标准输出 nmap -O -PN 192.168.244.160 -oX 1.xml #xml格式输出 nmap -O -PN 192.168.244.160 -oG 2.txt #grep格式输出 Nmap脚本使用 nmap --script 类别 Nmap脚本分类 - auth: 负责处理鉴权证书（绕开鉴权）的脚本 - broadcast: 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务 - brute: 提供暴力破解方式，针对常见的应用如http/snmp等 - default: 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力 - discovery: 对网络进行更多的信息，如SMB枚举、SNMP查询等 - dos: 用于进行拒绝服务攻击 - exploit: 利用已知的漏洞入侵系统 - external: 利用第三方的数据库或资源，例如进行whois解析 - fuzzer: 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞 - intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽 - malware: 探测目标机是否感染了病毒、开启了后门等信息 - safe: 此类与intrusive相反，属于安全性脚本 - version: 负责增强服务与版本扫描（Version Detection）功能的脚本 - vuln: 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067 使用具体脚本进行扫描 nmap --script 具体的脚本 www.baidu.com 常用脚本案例： 1、扫描服务器常见漏洞 nmap --script vuln \u003ctarget\u003e 2、检查FTP是否开启匿名登录 nmap --script ftp-anon \u003ctarget\u003e PORT STATE SERVICE 21/tcp open ftp | ftp-anon: Anonymous FTP login allowed (FTP code 230) | -rw-r--r-- 1 1170 924 31 Mar 28 2001 .banner | d--x--x--x 2 root root 1024 Jan 14 2002 bin | d--x--x--x 2 root root 1024 Aug 10 1999 etc | drwxr-srwt 2 1170 924 2048 Jul 19 18:48 incoming [NSE: writeable] | d--x--x--x 2 root root 1024 Jan 14 2002 lib | drwxr-sr-x 2 1170 924 1024 Aug 5 2004 pub |_Only 6 shown. Use --script-args ftp-anon.maxlist=-1 to see all. 3、对mysql进行暴力破解 ","date":"2023-03-28","objectID":"/post/543fca94/:1:17","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"参数速查 Nmap 支持主机名，网段的表示方式 例如:blah.highon.coffee, namp.org/24, 192.168.0.1;10.0.0-25.1-254 VERILOG-iL filename 从文件中读取待检测的目标,文件中的表示方法支持机名,ip,网段 -iR hostnum 随机选取,进行扫描.如果-iR指定为0,则是无休止的扫描 --exclude host1[, host2] 从扫描任务中需要排除的主机 --exculdefile exclude_file 排除文件中的IP,格式和-iL指定扫描文件的格式相同 ","date":"2023-03-28","objectID":"/post/543fca94/:2:0","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"主机发现 VERILOG-sL 仅仅是显示,扫描的IP数目,不会进行任何扫描 -sn ping扫描,即主机发现 -Pn 不检测主机存活 -PS/PA/PU/PY[portlist] TCP SYN Ping/TCP ACK Ping/UDP Ping发现 -PE/PP/PM 使用ICMP echo, timestamp and netmask 请求包发现主机 -PO[prococol list] 使用IP协议包探测对方主机是否开启 -n/-R 不对IP进行域名反向解析/为所有的IP都进行域名的反响解析 ","date":"2023-03-28","objectID":"/post/543fca94/:2:1","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"扫描技巧 VERILOG-sS/sT/sA/sW/sM TCP SYN/TCP connect()/ACK/TCP窗口扫描/TCP Maimon扫描 -sU UDP扫描 -sN/sF/sX TCP Null，FIN，and Xmas扫描 --scanflags 自定义TCP包中的flags -sI zombie host[:probeport] Idlescan -sY/sZ SCTP INIT/COOKIE-ECHO 扫描 -sO 使用IP protocol 扫描确定目标机支持的协议类型 -b “FTP relay host” 使用FTP bounce scan ","date":"2023-03-28","objectID":"/post/543fca94/:2:2","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"指定端口和扫描顺序 VERILOG-p 特定的端口 -p80,443 或者 -p1-65535 -p U:PORT 扫描udp的某个端口, -p U:53 -F 快速扫描模式,比默认的扫描端口还少 -r 不随机扫描端口,默认是随机扫描的 --top-ports \"number\" 扫描开放概率最高的number个端口,出现的概率需要参考nmap-services文件,ubuntu中该文件位于/usr/share/nmap.nmap默认扫前1000个 --port-ratio \"ratio\" 扫描指定频率以上的端口 ","date":"2023-03-28","objectID":"/post/543fca94/:2:3","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"服务版本识别 VERILOG-sV 开放版本探测,可以直接使用-A同时打开操作系统探测和版本探测 --version-intensity \"level\" 设置版本扫描强度,强度水平说明了应该使用哪些探测报文。数值越高，服务越有可能被正确识别。默认是7 --version-light 打开轻量级模式,为--version-intensity 2的别名 --version-all 尝试所有探测,为--version-intensity 9的别名 --version-trace 显示出详细的版本侦测过程信息 ","date":"2023-03-28","objectID":"/post/543fca94/:2:4","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"脚本扫描 VERILOG-sC 根据端口识别的服务,调用默认脚本 --script=”Lua scripts” 调用的脚本名 --script-args=n1=v1,[n2=v2] 调用的脚本传递的参数 --script-args-file=filename 使用文本传递参数 --script-trace 显示所有发送和接收到的数据 --script-updatedb 更新脚本的数据库 --script-help=”Lua script” 显示指定脚本的帮助 ","date":"2023-03-28","objectID":"/post/543fca94/:2:5","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"OS 识别 VERILOG-O 启用操作系统检测,-A来同时启用操作系统检测和版本检测 --osscan-limit 针对指定的目标进行操作系统检测(至少需确知该主机分别有一个open和closed的端口) --osscan-guess 推测操作系统检测结果,当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认进行这种匹配 ","date":"2023-03-28","objectID":"/post/543fca94/:2:6","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"防火墙 / IDS 躲避和哄骗 VERILOG-f; --mtu value 指定使用分片、指定数据包的MTU. -D decoy1,decoy2,ME 使用诱饵隐蔽扫描 -S IP-ADDRESS 源地址欺骗 -e interface 使用指定的接口 -g/ --source-port PROTNUM 使用指定源端口 --proxies url1,[url2],... 使用HTTP或者SOCKS4的代理 --data-length NUM 填充随机数据让数据包长度达到NUM --ip-options OPTIONS 使用指定的IP选项来发送数据包 --ttl VALUE 设置IP time-to-live域 --spoof-mac ADDR/PREFIX/VEBDOR MAC地址伪装 --badsum 使用错误的checksum来发送数据包 ","date":"2023-03-28","objectID":"/post/543fca94/:2:7","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"Nmap 输出 VERILOG-oN 将标准输出直接写入指定的文件 -oX 输出xml文件 -oS 将所有的输出都改为大写 -oG 输出便于通过bash或者perl处理的格式,非xml -oA BASENAME 可将扫描结果以标准格式、XML格式和Grep格式一次性输出 -v 提高输出信息的详细度 -d level 设置debug级别,最高是9 --reason 显示端口处于带确认状态的原因 --open 只输出端口状态为open的端口 --packet-trace 显示所有发送或者接收到的数据包 --iflist 显示路由信息和接口,便于调试 --log-errors 把日志等级为errors/warings的日志输出 --append-output 追加到指定的文件 --resume FILENAME 恢复已停止的扫描 --stylesheet PATH/URL 设置XSL样式表，转换XML输出 --webxml 从namp.org得到XML的样式 --no-sytlesheet 忽略XML声明的XSL样式表 ","date":"2023-03-28","objectID":"/post/543fca94/:2:8","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"其他 Nmap 选项 VERILOG-6 开启IPv6 -A OS识别,版本探测,脚本扫描和traceroute --datedir DIRNAME 说明用户Nmap数据文件位置 --send-eth / --send-ip 使用原以太网帧发送/在原IP层发送 --privileged 假定用户具有全部权限 --unprovoleged 假定用户不具有全部权限,创建原始套接字需要root权限 -V 打印版本信息 -h 输出帮助 ","date":"2023-03-28","objectID":"/post/543fca94/:2:9","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"常见端口对应服务 服务 端口 说明 FTP 20 FTP服务器真正传输所用的端口，用于上传、下载 FTP 21 用于FTP的登陆认证 SSH、SFTP 22 加密的远程登录，文件传输 Telnet 23 远程登录（在本地主机上使用此端口与远程服务器的22/3389端口连接） SMTP 25 用于发送邮件 HTTP 80 用于网页浏览 POP3 110 SUN公司的RPC服务所有端口 Network News Transfer Protocol 119 NEWS新闻组传输协议，承载USENET通信 SMTP 161 Simple Network Management Protocol，简单网络管理协议 SNMP Trap 162 SNMP陷阱 HTTPS 443 加密的网页浏览端口 CIFS 445 公共Internet文件系统 sql server 1433 Microsoft的SQL服务开放的端口 数据库 Oracle 1521 数据库 NFS 2049 通过网络，让不同的机器、不同的操作系统实现文件共享 MySQL 3306 数据库 WIN2003远程登录 3389 Windows 2000(2003) Server远程桌面的服务端口，本地服务器开放此端口，去连接到远程的服务器 QQ 4000 腾讯QQ客户端开放此端口 WebLogic 7001 一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器 Wingate 8010 Wingate代理开放此端口 TOMCAT 8080 WWW代理开放此端口 参考文章： Nmap 不老的神器 ","date":"2023-03-28","objectID":"/post/543fca94/:3:0","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["Golang"],"content":"Go5：数组与多维数组 ","date":"2023-03-21","objectID":"/post/5ded7b78/:0:0","tags":["Golang","编程"],"title":"Go入门日记-数组","uri":"/post/5ded7b78/"},{"categories":["Golang"],"content":"一 、数组 1.1 数组的声明 数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型 var arr1 [6]int //定义长度为6的整型数组，未初始化默认为0 //输出 [0 0 0 0 0 0] var arr2 = [...]int{1,2,3,4,5} //自动推导长度并初始化 //输出 [1 2 3 4 5] arr3 := [6]int{1,2,3,4,5,6} //定义并初始化 //输出 [1 2 3 4 5 6] arr3 := [...]int{2,3,4} //自动推导长度并初始化 //输出 [2 3 4] arr4 := [6]int{1,2} //指定固定长度，前几位被初始化，其他使用零值 // [1 2 0 0 0 0] arr5 := [6]int{1:9, 5:18} //将索引为 1 和 5 的元素初始化 //输出 [0 9 0 0 0 18] 1.2 数组常见操作 arr := [6]int{1,2,3,4,5,6} //输出所有元素 fmt.Println(arr) fmt.Println(arr[:]) //输出 [1 2 3 4 5 6] //输出前五个元素 fmt.Println(arr[:5]) //输出 [1 2 3 4 5] //输出从第5个开始（不包含第5个） fmt.Println(arr[5:]) //输出 [6] //数组的长度 fmt.Println(len(arr)) //输出 6 1.3 数组的遍历 arr := [3]int{1,2,3} for i := 0; i \u003c len(arr); i++ { fmt.Println(arr[i]) } //输出 1 2 3 arr := [3]int{1,2,3} for key, value := range arr { fmt.Println(key, value) } //输出 0 1 1 2 2 3 1.4 多维数组 //创建多维数组 var arr[2][2]int arr1 := [][]int{} //多维数组仅第一维度允许使用\"...\" arr2 := [...][2]int{ {1,2}, {3,4}, } 1.5 数组使用注意事项 数组创建完长度就固定，不可以再追加元素； 长度是数组类型的一部分，因此[3]int与[4]int是不同的类型； 数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该函数的副本，而不是他的指针。 ","date":"2023-03-21","objectID":"/post/5ded7b78/:0:1","tags":["Golang","编程"],"title":"Go入门日记-数组","uri":"/post/5ded7b78/"},{"categories":["Golang"],"content":"Go4：字符与字符串 ","date":"2023-03-15","objectID":"/post/ad0f0f0b/:0:0","tags":["Golang","编程"],"title":"Go入门日记-字符串","uri":"/post/ad0f0f0b/"},{"categories":["Golang"],"content":"一、字符 //在golang中没有专门的字符类型变量 var c1 byte = 'a' fmt.Println(\"c1=\", c1) //字符对应码大于255的字符可以使用int来保存 var c2 int = '成' fmt.Printf(\"c2=%c\\n\", c2) ","date":"2023-03-15","objectID":"/post/ad0f0f0b/:0:1","tags":["Golang","编程"],"title":"Go入门日记-字符串","uri":"/post/ad0f0f0b/"},{"categories":["Golang"],"content":"二、字符串 Tips：Go与传统的字符串不同，Go字符串是一串固定长度的字符连接起来的字符序列，字符串在内容初始化后不能被修改，都是采用UTF-8字符集编码。 var str1 string str1 = \"hello\" str2 := \"beijing\" //字符串不可直接改变 //str1[0]='c'会报错 fmt.Printf(\"%c\\n\", str1[1]) //输出 e fmt.Println(len(str2)) //输出 7 fmt.Println(str1 + str2) //输出 hellobeijing 修改字符串的间接方式： 1、通过两次转换来修改字符串 str := \"successful\" //转换成byte数组类型 strTemp := []byte(str) fmt.Println(\"strTemp=\", strTemp) //输出 //strTemp= [115 117 99 99 101 115 115 102 117 108] //修改数组的的值 strTemp[0] = 'c' //将数组转换成字符串 strResult := string(strTemp) fmt.Println(\"strResult=\", strResult) 2、使用切片来完成 str3 := \"liu\" str3 = \"c\" + str3[1:] fmt.Println(str3) //输出：ciu ","date":"2023-03-15","objectID":"/post/ad0f0f0b/:0:2","tags":["Golang","编程"],"title":"Go入门日记-字符串","uri":"/post/ad0f0f0b/"},{"categories":["Golang"],"content":"三、字符串操作 3.1 len()、string()函数 str4 := \"hello\" str5 := \"北京\" //在go语言中中文以utf-8格式保存，每个中文占据三个字节 fmt.Println(len(str4)) //输出 5 fmt.Println(len(str5)) //输出 6 //使用特定函数可以输出真正的字符串长度 fmt.Println(utf8.RuneCountInString(str5)) //输出 2 使用len()遍历字符串 str := \"你好\" for i,ch := range str { fmt.Println(i,ch) } //输出 0 20320 3 22909 string()函数 num := 108 fmt.Printf(\"%T \\n\", string(num)) //输出 string fmt.Printf(\"%s \\n\", string(num)) //输出 l 3.2 字符串连接 str1 = \"hello\" str2 := \"beijing\" fmt.Println(str1 + str2) //用+号来连接字符串不高效 //我们使用StringBuilder来高效字符串连接 //创建字节缓冲 var stringBuilder strings.Builder //把字符串写入缓冲 stringBuilder.WriteString(str1) stringBuilder.WriteString(str2) //将缓冲以字符串形式输出 fmt.Println(stringBuilder.String()) ","date":"2023-03-15","objectID":"/post/ad0f0f0b/:0:3","tags":["Golang","编程"],"title":"Go入门日记-字符串","uri":"/post/ad0f0f0b/"},{"categories":["Golang"],"content":"四、strings包相关函数 //查找s在字符串str中的索引 //Index(str, s string) int str := \"hello beijing\" s := \"e\" fmt.Println(strings.Index(str, s)) //输出 1 //判断str是否包含s //Contains(str, s string) bool fmt.Println(strings.Contains(str, s)) //输出 true //使用字符串str连接s的各个字符串 //Join(s []string, str string) string str := \"\u003c--\u003e\" s := []string{\"O\", \"O\", \"O\"} fmt.Println(strings.Join(s, str)) //输出 O\u003c--\u003eO\u003c--\u003eO //替换字符串str中old字符串为new字符串，n表示替换的次数，小于0全部替换 //Replace(str,old,new string,n int) string str := \"hello\" old := \"e\" new := \"o\" fmt.Println(strings.Replace(str, old, new, 1)) //输出 hollo //字符串str按照s分割，返回切片 //Split(str,s string)[]string str := \"php\" s := \"h\" fmt.Println(strings.Split(str, s)) //输出 [p p] // 去除头部、尾部指定的字符串 //Trim(s string, cutset string) string str := \"linux\" s := \"l\" fmt.Println(strings.Trim(str, s)) //输出 inux // 去除空格，返回切片 //Fields(s string) []string s := \"ha ha\" fmt.Println(strings.Fields(s)) //输出 [ha ha] ","date":"2023-03-15","objectID":"/post/ad0f0f0b/:0:4","tags":["Golang","编程"],"title":"Go入门日记-字符串","uri":"/post/ad0f0f0b/"},{"categories":["Golang"],"content":"五、strconv包的字符串转换 //整型转字符串 num := 100 str := strconv.Itoa(num) fmt.Printf(\"type: %T value: %#v\\n\", str, str) //输出 type: string value: \"100\" //字符串转整型(字符串中如果夹杂这非数字的字符则可能转换失败) str1 := \"110\" str2 := \"s100\" num1, err := strconv.Atoi(str1) if err != nil { fmt.Printf(\"%v 转换失败！\", str1) } else { fmt.Printf(\"type:%T value:%#v\\n\", num1, num1) } num2, err := strconv.Atoi(str2) if err != nil { fmt.Printf(\"%v 转换失败！\", str2) } else { fmt.Printf(\"type:%T value:%#v\\n\", num2, num2) } //输出 //type:int value:110 //s100 转换失败！ //Parse 系列函数 //ParseBool字符串转为布尔型 //只能接受 1、0、t、f、T、F、true、false、True、False、TRUE、FALSE其他都返回错误 str1 := \"t\" boo1, err := strconv.ParseBool(str1) if err != nil { fmt.Printf(\"str1: %v\\n\", err) } else { fmt.Println(boo1) } //输出 true //ParseInt返回字符串表示的整数值(包括正负号) //参数1: s string 数字的字符串形式 //参数2: base int 取值(2-36) //Tips: 如果base为0，根据字符串前置判断，“0x”是16进制，“0”是8进制，否则是10进制 //参数3: bitSize int 指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 //int、int8、int16、int32、int64,限制转化生成int类型的位数,但是返回结果都是int64 //可参考链接: https://studygolang.com/topics/12335 str := \"-11\" num, err := strconv.ParseInt(str, 10, 0) if err != nil { fmt.Println(err) } else { fmt.Println(num) } //输出 -11 //ParseUint函数的功能类似于ParseInt函数,只适用于无符号整数 //不再举例 //ParseFloat 函数用于将一个表示浮点数的字符串转换为 float 类型 //参数说明： //如果 s 合乎语法规则，函数会返回最为接近 s 表示值的一个浮点数（使用 IEEE754 规范舍入）。 //bitSize 指定了返回值的类型，32 表示 float32，64 表示 float64； //返回值 err 是 *NumErr 类型的，如果语法有误 err.Error=ErrSyntax， //如果返回值超出表示范围，返回值 f 为 ±Inf，err.Error= ErrRange。 //Format 系列函数 //FormatBool函数可以一个bool类型的值转换为对应的字符串类型 num := true str := strconv.FormatBool(num) fmt.Printf(\"type:%T,value:%v\\n \", str, str) //输出 type:string,value:true //FormatInt函数将整型数据转成指定类型字符串 //Tips:参数 i 必须是 int64 类型 var num int64 = 16 str := strconv.FormatInt(num, 16) fmt.Printf(\"type:%T,value:%v\\n \", str, str) //输出 type:string,value:10 //FormatUint函数与FormatInt函数的功能类似，但是参数 i 必须是无符号的 uint64 类型 //不再举例 //FormatFloat函数用于将浮点数转换为字符串类型 //参数1: bitSize 参数f的来源类型（32表示float32、64表示float64）会据此进行舍入 //参数2: fmt 表示格式，可以设置为“f”表示 -ddd.dddd、“b”表示 -ddddp±ddd，指数为二进制、 //“e”表示 -d.dddde±dd 十进制指数、“E”表示 -d.ddddE±dd 十进制指数、“g”表示指数很大时用“e”格式， //否则“f”格式、“G”表示指数很大时用“E”格式，否则“f”格式。 //参数3: prec 控制精度（排除指数部分）：当参数 fmt 为“f”、“e”、“E”时，它表示小数点后的数字个数 //当参数 fmt 为“g”、“G”时，它控制总的数字个数。 //如果 prec 为 -1，则代表使用最少数量的、但又必需的数字来表示 f。 var num float64 = 3.1415926 str := strconv.FormatFloat(num, 'E', -1, 64) fmt.Printf(\"type:%T,value:%v\\n \", str, str) //输出 type:string,value:3.1415926E+00 //Append 系列函数 // 声明一个slice b10 := []byte(\"int (base 10):\") // 将转换为10进制的string，追加到slice中 b10 = strconv.AppendInt(b10, -42, 10) fmt.Println(string(b10)) b16 := []byte(\"int (base 16):\") b16 = strconv.AppendInt(b16, -42, 16) fmt.Println(string(b16)) //输出 int (base 10):-42 int (base 16):-2a ","date":"2023-03-15","objectID":"/post/ad0f0f0b/:0:5","tags":["Golang","编程"],"title":"Go入门日记-字符串","uri":"/post/ad0f0f0b/"},{"categories":["Golang"],"content":"Go3：流程控制 ","date":"2023-03-15","objectID":"/post/fd173a46/:0:0","tags":["Golang","编程"],"title":"Go入门日记-流程控制","uri":"/post/fd173a46/"},{"categories":["Golang"],"content":"一、条件语句 1.1 if判断语句： if i == 3{ //如果i等于3输出true fmt.Println(\"true\") } //将初始化条件与判断语句放在一起 if i := 3;i == 3{ //如果i等于3输出true fmt.Println(\"true\") } 1.2 分支语句 //Go语言中分支语句中默认书写了break语句 num := 2 switch num { case 1: fmt.Println(\"111\") case 2: fmt.Println(\"222\") fallthrough //fallthrough 不跳出switch case 3: fmt.Println(\"333\") default: fmt.Println(\"默认\") } //输出： 222 333 ","date":"2023-03-15","objectID":"/post/fd173a46/:0:1","tags":["Golang","编程"],"title":"Go入门日记-流程控制","uri":"/post/fd173a46/"},{"categories":["Golang"],"content":"二、循环语句 2.1 for循环 //传统for循环 for i := 0; i \u003c 10; i++ { fmt.Println(i) } //for循环简化 var i int for ; ; i++ { if i \u003e 10 { break } } //类似while循环 for i \u003c 10 { i++ } //死循环 for{ } //for range 遍历数组等 for k, v := range []int{1, 2, 3, 4} { fmt.Printf(\"key:%d value:%d\\n\", k, v) } //输出： key:0 value:1 key:1 value:2 key:2 value:3 key:3 value:4 2.2 跳出循环 常用的跳出循环关键字： break用于函数内跳出当前for、switch、select语句的执行 continue用于跳出for循环的本次迭代。 goto可以退出多层循环 goto 标签 标签： ","date":"2023-03-15","objectID":"/post/fd173a46/:0:2","tags":["Golang","编程"],"title":"Go入门日记-流程控制","uri":"/post/fd173a46/"},{"categories":["Golang"],"content":"Go2：数据类型初识 ","date":"2023-03-15","objectID":"/post/71c0dfce/:0:0","tags":["Golang","编程"],"title":"Go入门日记-数据类型","uri":"/post/71c0dfce/"},{"categories":["Golang"],"content":"一、数据类型分类 Go 语言按类别有以下几种数据类型：布尔型、数字型、字符串型、派生型 整型 int8、uint等 数字型 浮点型 float32、float64等 数字型 复数 数字型 布尔型 bool 布尔型 字符串 string 字符串型 数组 派生型 结构体 struct 派生型 引用类型：即保存的是对程序中一个变量的或状态的间接引用，对其修改将影响所有该引用的拷贝 指针 * 切片 slice 字典 map 函数 func 管道 chan 接口 interface tip：Go语言没有字符型，可以使用byte来保存单个字母 ","date":"2023-03-15","objectID":"/post/71c0dfce/:0:1","tags":["Golang","编程"],"title":"Go入门日记-数据类型","uri":"/post/71c0dfce/"},{"categories":["Golang"],"content":"二 、零值机制 Go变量初始化会自带默认值，不像其他语言为空，下面列出各种数据类型对应的0值： int 0 int8 0 int32 0 int64 0 uint 0x0 rune 0 //rune的实际类型是 int32 byte 0x0 // byte的实际类型是 uint8 float32 0 //长度为 4 byte float64 0 //长度为 8 byte bool false string \"\" ","date":"2023-03-15","objectID":"/post/71c0dfce/:0:2","tags":["Golang","编程"],"title":"Go入门日记-数据类型","uri":"/post/71c0dfce/"},{"categories":["Golang"],"content":"Go1：语言标识符与变量 ","date":"2023-03-14","objectID":"/post/1025c530/:0:0","tags":["Golang","编程"],"title":"Go入门日记-标识符与变量","uri":"/post/1025c530/"},{"categories":["Golang"],"content":"1.1关键字 目前Go语言有25个关键字 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var ","date":"2023-03-14","objectID":"/post/1025c530/:0:1","tags":["Golang","编程"],"title":"Go入门日记-标识符与变量","uri":"/post/1025c530/"},{"categories":["Golang"],"content":"1.2保留字 //内建常量： true false iota nil //内建类型： int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 //bool： byte rune string error //内建函数： make delete complex panic append copy close len cap real imag new recover ","date":"2023-03-14","objectID":"/post/1025c530/:0:2","tags":["Golang","编程"],"title":"Go入门日记-标识符与变量","uri":"/post/1025c530/"},{"categories":["Golang"],"content":"二、变量 2.1变量声明 var a int //初始化变量默认为0 var b = 1 //声明并赋值，自动推导变量类型 c := 2 //初始化，自动推导类型(只能在函数内部使用，var定义全局变量) //Go语言中有定义未使用的变量编译会报错 //大小写变量为不同变量 2.2多变量声明 var c,d int var c1,d1 int = 1,2 var c1,d1 = 1,2 c,d := 1,2 var( e int f byte ) 2.3变量值互换 在Go语言中两个变量互换的操作十分简单 var ( //定义初始化变量 m int = 1 n int = 2 temp int = 6 ) m,n = n,m //将m与n的变量值互换 fmt.Println(m, n) //2 1 2.4_丢弃变量 //_丢弃变量任何赋予它的值都会被丢弃，该变量不占用命名空间 _,d := 1,2 //此时d的值为2，1被丢弃掉 ","date":"2023-03-14","objectID":"/post/1025c530/:1:0","tags":["Golang","编程"],"title":"Go入门日记-标识符与变量","uri":"/post/1025c530/"},{"categories":null,"content":" 关于我 生活明朗，万物向上 你好，很高兴认识你👋 我叫浔若 是一名 在校大学生 追求 源于 热爱而去感受 学习 生活 程序 体验 技能开启创造力 Vue React Docker Photoshop Node Webpack Pinia Python Vite Flutter Java CSS3 JS HTML Git Apifox ... 数据访问统计 统计信息来自51la网站统计 性格倡导者 INFJ-T 座右铭每天，进步一点点。 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":" 添加友链，评论格式如下： - nickname: \u003cyour nickname\u003e avatar: \u003cyour avatar\u003e url: \u003cyour site link\u003e description: \u003cdescription of your site\u003e ","date":"0001-01-01","objectID":"/friends/:0:0","tags":null,"title":"友情链接","uri":"/friends/"}]